// Generated by generate_plugin_gmmproc_file. Don't edit this file.


_PINCLUDE(gstreamermm/private/basesink_p.h)

extern "C"
{

GType gst_multi_socket_sink_gstreamermm_get_type()
{
  static GType type = 0;
  GstElementFactory* factory = 0;
  GstPluginFeature* feature = 0;

  if(!type)
  {
    factory = gst_element_factory_find("multisocketsink");
    // Make sure that the feature is actually loaded:
    if(factory)
    {
      feature =
        gst_plugin_feature_load(GST_PLUGIN_FEATURE(factory));

      g_object_unref(factory);
      factory = GST_ELEMENT_FACTORY(feature);
      type = gst_element_factory_get_element_type(factory);
      g_object_unref(factory);
    }
  }

  return type;
}

} // extern "C"

namespace Gst
{

MultiSocketSink::MultiSocketSink()
: _CONSTRUCT("name", static_cast<char*>(0))
{}

MultiSocketSink::MultiSocketSink(const Glib::ustring& name)
: _CONSTRUCT("name", name.c_str())
{}

void MultiSocketSink::add(const Glib::RefPtr<Gio::Socket>& arg0)
{
  g_signal_emit_by_name(gobj(), "add", _CONVERT(`const Glib::RefPtr<Gio::Socket>&', `GSocket*', `arg0'), static_cast<void*>(0));
}

void MultiSocketSink::add_full(const Glib::RefPtr<Gio::Socket>& arg0, Gst::MultiHandleSinkSyncMethod arg1, Gst::Format arg2, guint64 arg3, Gst::Format arg4, guint64 arg5)
{
  g_signal_emit_by_name(gobj(), "add-full", _CONVERT(`const Glib::RefPtr<Gio::Socket>&', `GSocket*', `arg0'), _CONVERT(`Gst::MultiHandleSinkSyncMethod', `GstMultiHandleSinkSyncMethod', `arg1'), _CONVERT(`Gst::Format', `GstFormat', `arg2'), _CONVERT(`guint64', `guint64', `arg3'), _CONVERT(`Gst::Format', `GstFormat', `arg4'), _CONVERT(`guint64', `guint64', `arg5'), static_cast<void*>(0));
}

void MultiSocketSink::remove(const Glib::RefPtr<Gio::Socket>& arg0)
{
  g_signal_emit_by_name(gobj(), "remove", _CONVERT(`const Glib::RefPtr<Gio::Socket>&', `GSocket*', `arg0'), static_cast<void*>(0));
}

void MultiSocketSink::remove_flush(const Glib::RefPtr<Gio::Socket>& arg0)
{
  g_signal_emit_by_name(gobj(), "remove-flush", _CONVERT(`const Glib::RefPtr<Gio::Socket>&', `GSocket*', `arg0'), static_cast<void*>(0));
}

Gst::Structure MultiSocketSink::get_stats(const Glib::RefPtr<Gio::Socket>& arg0)
{
  GstStructure* result;
  g_signal_emit_by_name(gobj(), "get-stats", _CONVERT(`const Glib::RefPtr<Gio::Socket>&', `GSocket*', `arg0'), &result, static_cast<void*>(0));
  return _CONVERT(`GstStructure*', `Gst::Structure', `result');
}

}
