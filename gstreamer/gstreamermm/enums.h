// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!
#ifndef _GSTREAMERMM_ENUMS_H
#define _GSTREAMERMM_ENUMS_H


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gst.h>


// Plug-in C enums used in the plug-in signals that are shared need to be
// declared.  This one is is shared between decodebin2 and uridecodebin so it
// is difficult for it to be generated.
enum GstAutoplugSelectResult
{
  GST_AUTOPLUG_SELECT_TRY,
  GST_AUTOPLUG_SELECT_EXPOSE,
  GST_AUTOPLUG_SELECT_SKIP
};

enum GstMultiHandleSinkClientStatus
{
  GST_CLIENT_STATUS_OK,
  GST_CLIENT_STATUS_CLOSED,
  GST_CLIENT_STATUS_REMOVED,
  GST_CLIENT_STATUS_SLOW,
  GST_CLIENT_STATUS_ERROR,
  GST_CLIENT_STATUS_DUPLICATE,
  GST_CLIENT_STATUS_FLUSHING
};

enum GstMultiHandleSinkSyncMethod
{
  GST_SYNC_METHOD_LATEST,
  GST_SYNC_METHOD_NEXT_KEYFRAME,
  GST_SYNC_METHOD_LATEST_KEYFRAME,
  GST_SYNC_METHOD_BURST,
  GST_SYNC_METHOD_BURST_KEYFRAME,
  GST_SYNC_METHOD_BURST_WITH_KEYFRAME
};

namespace Gst
{

/** @addtogroup gstreamermmEnums gstreamermm Enums and Flags */

/** 
 *  @var State STATE_VOID_PENDING
 * No pending state.
 * 
 *  @var State STATE_NULL
 * The <tt>nullptr</tt> state or initial state of an element.
 * 
 *  @var State STATE_READY
 * The element is ready to go to PAUSED.
 * 
 *  @var State STATE_PAUSED
 * The element is PAUSED, it is ready to accept and
 * process data. Sink elements however only accept one
 * buffer and then block.
 * 
 *  @var State STATE_PLAYING
 * The element is PLAYING, the Gst::Clock is running and
 * the data is flowing.
 * 
 *  @enum State
 * 
 * The possible states an element can be in. States can be changed using
 * Gst::Element::set_state() and checked using Gst::Element::get_state().
 *
 * @ingroup gstreamermmEnums
 */
enum State
{
  STATE_VOID_PENDING,
  STATE_NULL,
  STATE_READY,
  STATE_PAUSED,
  STATE_PLAYING
};

} // namespace Gst

#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::State> : public Glib::Value_Enum<Gst::State>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gst
{


// Plug-in non-genereated enums.  Handled manually and not generated because
// they are shared by more than one plug-in:
/** 
 *
 * @ingroup gstreamermmEnums
 */
enum AutoplugSelectResult
{
  AUTOPLUG_SELECT_TRY,
  AUTOPLUG_SELECT_EXPOSE,
  AUTOPLUG_SELECT_SKIP
};

} // namespace Gst

#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::AutoplugSelectResult> : public Glib::Value_Enum<Gst::AutoplugSelectResult>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gst
{


/** 
 *
 * @ingroup gstreamermmEnums
 */
enum MultiHandleSinkClientStatus
{
  CLIENT_STATUS_OK,
  CLIENT_STATUS_CLOSED,
  CLIENT_STATUS_REMOVED,
  CLIENT_STATUS_SLOW,
  CLIENT_STATUS_ERROR,
  CLIENT_STATUS_DUPLICATE,
  CLIENT_STATUS_FLUSHING
};

} // namespace Gst

#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::MultiHandleSinkClientStatus> : public Glib::Value_Enum<Gst::MultiHandleSinkClientStatus>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gst
{


/** 
 *
 * @ingroup gstreamermmEnums
 */
enum MultiHandleSinkSyncMethod
{
  SYNC_METHOD_LATEST,
  SYNC_METHOD_NEXT_KEYFRAME,
  SYNC_METHOD_LATEST_KEYFRAME,
  SYNC_METHOD_BURST,
  SYNC_METHOD_BURST_KEYFRAME,
  SYNC_METHOD_BURST_WITH_KEYFRAME
};

} // namespace Gst

#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::MultiHandleSinkSyncMethod> : public Glib::Value_Enum<Gst::MultiHandleSinkSyncMethod>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gst
{


/** 
 *
 * @ingroup gstreamermmEnums
 * @par Bitwise operators:
 * <tt>%PlayFlags operator|(PlayFlags, PlayFlags)</tt><br>
 * <tt>%PlayFlags operator&(PlayFlags, PlayFlags)</tt><br>
 * <tt>%PlayFlags operator^(PlayFlags, PlayFlags)</tt><br>
 * <tt>%PlayFlags operator~(PlayFlags)</tt><br>
 * <tt>%PlayFlags& operator|=(PlayFlags&, PlayFlags)</tt><br>
 * <tt>%PlayFlags& operator&=(PlayFlags&, PlayFlags)</tt><br>
 * <tt>%PlayFlags& operator^=(PlayFlags&, PlayFlags)</tt><br>
 */
enum PlayFlags
{
  PLAY_FLAG_VIDEO = (1 << 0),
  PLAY_FLAG_AUDIO = (1 << 1),
  PLAY_FLAG_TEXT = (1 << 2),
  PLAY_FLAG_VIS = (1 << 3),
  PLAY_FLAG_SOFT_VOLUME = (1 << 4),
  PLAY_FLAG_NATIVE_AUDIO = (1 << 5),
  PLAY_FLAG_NATIVE_VIDEO = (1 << 6),
  PLAY_FLAG_DOWNLOAD = (1 << 7),
  PLAY_FLAG_BUFFERING = (1 << 8),
  PLAY_FLAG_DEINTERLACE = (1 << 9),
  PLAY_FLAG_SOFT_COLORBALANCE = (1 << 10),
  PLAY_FLAG_FORCE_FILTERS = (1 << 11)
};

/** @ingroup gstreamermmEnums */
inline PlayFlags operator|(PlayFlags lhs, PlayFlags rhs)
  { return static_cast<PlayFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gstreamermmEnums */
inline PlayFlags operator&(PlayFlags lhs, PlayFlags rhs)
  { return static_cast<PlayFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gstreamermmEnums */
inline PlayFlags operator^(PlayFlags lhs, PlayFlags rhs)
  { return static_cast<PlayFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gstreamermmEnums */
inline PlayFlags operator~(PlayFlags flags)
  { return static_cast<PlayFlags>(~static_cast<unsigned>(flags)); }

/** @ingroup gstreamermmEnums */
inline PlayFlags& operator|=(PlayFlags& lhs, PlayFlags rhs)
  { return (lhs = static_cast<PlayFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gstreamermmEnums */
inline PlayFlags& operator&=(PlayFlags& lhs, PlayFlags rhs)
  { return (lhs = static_cast<PlayFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gstreamermmEnums */
inline PlayFlags& operator^=(PlayFlags& lhs, PlayFlags rhs)
  { return (lhs = static_cast<PlayFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace Gst

#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::PlayFlags> : public Glib::Value_Flags<Gst::PlayFlags>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gst
{


} //namespace Gst


#endif /* _GSTREAMERMM_ENUMS_H */

