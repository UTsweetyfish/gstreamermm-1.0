// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gstreamermm/clock.h>
#include <gstreamermm/private/clock_p.h>


/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2016 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace
{

extern "C"
{

static gboolean ClockID_Clock_gstreamermm_callback(GstClock* clock, GstClockTime time, GstClockID id, void* data)
{
  Gst::ClockID::SlotClock* the_slot = static_cast<Gst::ClockID::SlotClock*>(data);

  try
  {
    bool result = (*the_slot)(Glib::wrap(clock, true), time,
      Glib::wrap(reinterpret_cast<GstClockEntry*>(id), true));

    //Delete the once executing slot before returning result
    delete the_slot;

    return result;
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
  }

  return false;
}


static void ClockID_Clock_gstreamermm_callback_destroy(void* data)
{
  delete static_cast<Gst::ClockID::SlotClock*>(data);
}

} // extern "C"

} // anonymous namespace

namespace Gst
{

ClockReturn ClockID::wait_async(const SlotClock& slot)
{
  SlotClock* slot_copy = new SlotClock(slot);
  return static_cast<ClockReturn>(gst_clock_id_wait_async(gobj(), &ClockID_Clock_gstreamermm_callback, slot_copy, &ClockID_Clock_gstreamermm_callback_destroy));
}

}

namespace
{


static void Clock_signal_synced_callback(GstClock* self, gboolean p0,void* data)
{
  using namespace Gst;
  using SlotType = sigc::slot< void,bool >;

  auto obj = dynamic_cast<Clock*>(Glib::ObjectBase::_get_current_wrapper((GObject*) self));
  // Do not try to call a signal on a disassociated wrapper.
  if(obj)
  {
    try
    {
      if(const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    }
    catch(...)
    {
       Glib::exception_handlers_invoke();
    }
  }
}

static const Glib::SignalProxyInfo Clock_signal_synced_info =
{
  "synced",
  (GCallback) &Clock_signal_synced_callback,
  (GCallback) &Clock_signal_synced_callback
};


} // anonymous namespace


/* Why reinterpret_cast<ClockID*>(gobject) is needed:
 *
 * A ClockID instance is in fact always a GstClockEntry instance.
 * Unfortunately, GstClockEntry cannot be a member of ClockID,
 * because it is an opaque struct.  Also, the C interface does not provide
 * any hooks to install a destroy notification handler, thus we cannot
 * wrap it dynamically either.
 *
 * The cast works because ClockID does not have any member data, and
 * it is impossible to derive from it.  This is ensured by using final on the
 * class and by using = delete on the default constructor.
 */

namespace Glib
{

Glib::RefPtr<Gst::ClockID> wrap(GstClockEntry* object, bool take_copy)
{
  if(take_copy && object)
    gst_clock_id_ref(object);

  // See the comment at the top of this file, if you want to know why the cast works.
  return Glib::RefPtr<Gst::ClockID>(reinterpret_cast<Gst::ClockID*>(object));
}

} // namespace Glib


namespace Gst
{


void ClockID::reference() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  gst_clock_id_ref(reinterpret_cast<GstClockEntry*>(const_cast<ClockID*>(this)));
}

void ClockID::unreference() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  gst_clock_id_unref(reinterpret_cast<GstClockEntry*>(const_cast<ClockID*>(this)));
}

GstClockEntry* ClockID::gobj()
{
  // See the comment at the top of this file, if you want to know why the cast works.
  return reinterpret_cast<GstClockEntry*>(this);
}

const GstClockEntry* ClockID::gobj() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  return reinterpret_cast<const GstClockEntry*>(this);
}

GstClockEntry* ClockID::gobj_copy() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  const auto gobject = reinterpret_cast<GstClockEntry*>(const_cast<ClockID*>(this));
  gst_clock_id_ref(gobject);
  return gobject;
}


Gst::ClockTime ClockID::get_time() const
{
  return ((Gst::ClockTime)(gst_clock_id_get_time(const_cast<GstClockEntry*>(gobj()))));
}

ClockReturn ClockID::wait(Gst::ClockTimeDiff& jitter)
{
  return ((ClockReturn)(gst_clock_id_wait(gobj(), (GstClockTimeDiff*)(&jitter))));
}

ClockReturn ClockID::wait()
{
  return ((ClockReturn)(gst_clock_id_wait(gobj(), nullptr)));
}

void ClockID::unschedule()
{
  gst_clock_id_unschedule(gobj());
}


} // namespace Gst


namespace Glib
{

Glib::RefPtr<Gst::Clock> wrap(GstClock* object, bool take_copy)
{
  return Glib::RefPtr<Gst::Clock>( dynamic_cast<Gst::Clock*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gst
{


/* The *_Class implementation: */

const Glib::Class& Clock_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Clock_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gst_clock_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void Clock_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

  klass->change_resolution = &change_resolution_vfunc_callback;
  klass->get_resolution = &get_resolution_vfunc_callback;
  klass->get_internal_time = &get_internal_time_vfunc_callback;
  klass->wait = &wait_vfunc_callback;
  klass->wait_async = &wait_async_vfunc_callback;
  klass->unschedule = &unschedule_vfunc_callback;

}

GstClockTime Clock_Class::change_resolution_vfunc_callback(GstClock* self, GstClockTime old_resolution, GstClockTime new_resolution)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstClockTime)(obj->change_resolution_vfunc(((Gst::ClockTime)(old_resolution))
, ((Gst::ClockTime)(new_resolution))
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->change_resolution)
    return (*base->change_resolution)(self, old_resolution, new_resolution);

  using RType = GstClockTime;
  return RType();
}
GstClockTime Clock_Class::get_resolution_vfunc_callback(GstClock* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstClockTime)(obj->get_resolution_vfunc()));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->get_resolution)
    return (*base->get_resolution)(self);

  using RType = GstClockTime;
  return RType();
}
GstClockTime Clock_Class::get_internal_time_vfunc_callback(GstClock* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstClockTime)(obj->get_internal_time_vfunc()));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->get_internal_time)
    return (*base->get_internal_time)(self);

  using RType = GstClockTime;
  return RType();
}
GstClockReturn Clock_Class::wait_vfunc_callback(GstClock* self, GstClockEntry* entry, GstClockTimeDiff* jitter)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstClockReturn)(obj->wait_vfunc(Glib::wrap(entry, true)
, (Gst::ClockTimeDiff&)(*jitter)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->wait)
    return (*base->wait)(self, entry, jitter);

  using RType = GstClockReturn;
  return RType();
}
GstClockReturn Clock_Class::wait_async_vfunc_callback(GstClock* self, GstClockEntry* entry)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstClockReturn)(obj->wait_async_vfunc(Glib::wrap(entry, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->wait_async)
    return (*base->wait_async)(self, entry);

  using RType = GstClockReturn;
  return RType();
}
void Clock_Class::unschedule_vfunc_callback(GstClock* self, GstClockEntry* entry)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        obj->unschedule_vfunc(Glib::wrap(entry, true)
);
        return;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->unschedule)
    (*base->unschedule)(self, entry);
}


Glib::ObjectBase* Clock_Class::wrap_new(GObject* object)
{
  return new Clock((GstClock*)object);
}


/* The implementation: */

GstClock* Clock::gobj_copy()
{
  reference();
  return gobj();
}

Clock::Clock(const Glib::ConstructParams& construct_params)
:
  Object(construct_params)
{

}

Clock::Clock(GstClock* castitem)
:
  Object((GstObject*)(castitem))
{}


Clock::Clock(Clock&& src) noexcept
: Object(std::move(src))
{}

Clock& Clock::operator=(Clock&& src) noexcept
{
  Object::operator=(std::move(src));
  return *this;
}


Clock::~Clock() noexcept
{}


Clock::CppClassType Clock::clock_class_; // initialize static member

GType Clock::get_type()
{
  return clock_class_.init().get_type();
}


GType Clock::get_base_type()
{
  return gst_clock_get_type();
}

bool Clock::add_observation(Gst::ClockTime slave_time, Gst::ClockTime master_time, gdouble& result)
{
  return gst_clock_add_observation(gobj(), ((GstClockTime)(slave_time)), ((GstClockTime)(master_time)), &result);
}

bool Clock::add_observation(Gst::ClockTime slave_time, Gst::ClockTime master_time, gdouble& result, Gst::ClockTime& internal, Gst::ClockTime& external, Gst::ClockTime& rate_num, Gst::ClockTime& rate_denom)
{
  return gst_clock_add_observation_unapplied(gobj(), ((GstClockTime)(slave_time)), ((GstClockTime)(master_time)), &result, (GstClockTime*)(&internal), (GstClockTime*)(&external), (GstClockTime*)(&rate_num), (GstClockTime*)(&rate_denom));
}

bool Clock::set_master(const Clock& master_clock)
{
  return gst_clock_set_master(gobj(), ((GstClock*)(&master_clock)));
}

Glib::RefPtr<Gst::Clock> Clock::get_master()
{
  return Glib::wrap(gst_clock_get_master(gobj()));
}

Glib::RefPtr<const Gst::Clock> Clock::get_master() const
{
  return const_cast<Clock*>(this)->get_master();
}

Gst::ClockTime Clock::set_resolution(Gst::ClockTime resolution)
{
  return ((Gst::ClockTime)(gst_clock_set_resolution(gobj(), ((GstClockTime)(resolution)))));
}

Gst::ClockTime Clock::get_resolution() const
{
  return ((Gst::ClockTime)(gst_clock_get_resolution(const_cast<GstClock*>(gobj()))));
}

Gst::ClockTime Clock::get_time() const
{
  return ((Gst::ClockTime)(gst_clock_get_time(const_cast<GstClock*>(gobj()))));
}

Glib::RefPtr<Gst::ClockID> Clock::create_single_shot_id(Gst::ClockTime time)
{
  return Glib::wrap((GstClockEntry*)(gst_clock_new_single_shot_id(gobj(), ((GstClockTime)(time)))));
}

Glib::RefPtr<Gst::ClockID> Clock::create_periodic_id(Gst::ClockTime start_time, Gst::ClockTime intervals)
{
  return Glib::wrap((GstClockEntry*)(gst_clock_new_periodic_id(gobj(), ((GstClockTime)(start_time)), ((GstClockTime)(intervals)))));
}

bool Clock::single_shot_id_reinit(const Glib::RefPtr<Gst::ClockID>& id, Gst::ClockTime time)
{
  return gst_clock_single_shot_id_reinit(gobj(), Glib::unwrap(id), ((GstClockTime)(time)));
}

bool Clock::periodic_id_reinit(const Glib::RefPtr<Gst::ClockID>& id, Gst::ClockTime start_time, Gst::ClockTime interval)
{
  return gst_clock_periodic_id_reinit(gobj(), Glib::unwrap(id), ((GstClockTime)(start_time)), ((GstClockTime)(interval)));
}

Gst::ClockTime Clock::get_internal_time() const
{
  return ((Gst::ClockTime)(gst_clock_get_internal_time(const_cast<GstClock*>(gobj()))));
}

Gst::ClockTime Clock::adjust_unlocked(Gst::ClockTime internal_time)
{
  return ((Gst::ClockTime)(gst_clock_adjust_unlocked(gobj(), ((GstClockTime)(internal_time)))));
}

Gst::ClockTime Clock::unadjust_unlocked(Gst::ClockTime external_time)
{
  return ((Gst::ClockTime)(gst_clock_unadjust_unlocked(gobj(), ((GstClockTime)(external_time)))));
}

Gst::ClockTime Clock::adjust_with_calibration(Gst::ClockTime internal_target, Gst::ClockTime cinternal, Gst::ClockTime cexternal, Gst::ClockTime cnum, Gst::ClockTime cdenom)
{
  return ((Gst::ClockTime)(gst_clock_adjust_with_calibration(gobj(), ((GstClockTime)(internal_target)), ((GstClockTime)(cinternal)), ((GstClockTime)(cexternal)), ((GstClockTime)(cnum)), ((GstClockTime)(cdenom)))));
}

Gst::ClockTime Clock::unadjust_with_calibration(Gst::ClockTime external_target, Gst::ClockTime cinternal, Gst::ClockTime cexternal, Gst::ClockTime cnum, Gst::ClockTime cdenom)
{
  return ((Gst::ClockTime)(gst_clock_unadjust_with_calibration(gobj(), ((GstClockTime)(external_target)), ((GstClockTime)(cinternal)), ((GstClockTime)(cexternal)), ((GstClockTime)(cnum)), ((GstClockTime)(cdenom)))));
}

void Clock::get_calibration(Gst::ClockTime& internal, Gst::ClockTime& external, Gst::ClockTime& rate_num, Gst::ClockTime& rate_denom) const
{
  gst_clock_get_calibration(const_cast<GstClock*>(gobj()), (GstClockTime*)(&internal), (GstClockTime*)(&external), (GstClockTime*)(&rate_num), (GstClockTime*)(&rate_denom));
}

void Clock::set_calibration(Gst::ClockTime internal, Gst::ClockTime external, Gst::ClockTime rate_num, Gst::ClockTime rate_denom)
{
  gst_clock_set_calibration(gobj(), ((GstClockTime)(internal)), ((GstClockTime)(external)), ((GstClockTime)(rate_num)), ((GstClockTime)(rate_denom)));
}

bool Clock::wait_for_sync(Gst::ClockTime timeout)
{
  return gst_clock_wait_for_sync(gobj(), ((GstClockTime)(timeout)));
}

bool Clock::is_synced() const
{
  return gst_clock_is_synced(const_cast<GstClock*>(gobj()));
}

void Clock::set_synced(bool synced)
{
  gst_clock_set_synced(gobj(), static_cast<int>(synced));
}


Glib::SignalProxy< void,bool > Clock::signal_synced()
{
  return Glib::SignalProxy< void,bool >(this, &Clock_signal_synced_info);
}


Glib::PropertyProxy< guint64 > Clock::property_timeout() 
{
  return Glib::PropertyProxy< guint64 >(this, "timeout");
}

Glib::PropertyProxy_ReadOnly< guint64 > Clock::property_timeout() const
{
  return Glib::PropertyProxy_ReadOnly< guint64 >(this, "timeout");
}

Glib::PropertyProxy< int > Clock::property_window_size() 
{
  return Glib::PropertyProxy< int >(this, "window-size");
}

Glib::PropertyProxy_ReadOnly< int > Clock::property_window_size() const
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "window-size");
}

Glib::PropertyProxy< int > Clock::property_window_threshold() 
{
  return Glib::PropertyProxy< int >(this, "window-threshold");
}

Glib::PropertyProxy_ReadOnly< int > Clock::property_window_threshold() const
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "window-threshold");
}


Gst::ClockTime Gst::Clock::change_resolution_vfunc(Gst::ClockTime old_resolution, Gst::ClockTime new_resolution) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->change_resolution)
  {
    Gst::ClockTime retval(((Gst::ClockTime)((*base->change_resolution)(gobj(),((GstClockTime)(old_resolution)),((GstClockTime)(new_resolution))))));
    return retval;
  }

  using RType = Gst::ClockTime;
  return RType();
}
Gst::ClockTime Gst::Clock::get_resolution_vfunc() const
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->get_resolution)
  {
    Gst::ClockTime retval(((Gst::ClockTime)((*base->get_resolution)(const_cast<GstClock*>(gobj())))));
    return retval;
  }

  using RType = Gst::ClockTime;
  return RType();
}
Gst::ClockTime Gst::Clock::get_internal_time_vfunc() const
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->get_internal_time)
  {
    Gst::ClockTime retval(((Gst::ClockTime)((*base->get_internal_time)(const_cast<GstClock*>(gobj())))));
    return retval;
  }

  using RType = Gst::ClockTime;
  return RType();
}
ClockReturn Gst::Clock::wait_vfunc(const Glib::RefPtr<Gst::ClockID>& id, Gst::ClockTimeDiff& jitter) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->wait)
  {
    ClockReturn retval(((ClockReturn)((*base->wait)(gobj(),Glib::unwrap(id),(GstClockTimeDiff*)(&jitter)))));
    return retval;
  }

  using RType = ClockReturn;
  return RType();
}
ClockReturn Gst::Clock::wait_async_vfunc(const Glib::RefPtr<Gst::ClockID>& id) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->wait_async)
  {
    ClockReturn retval(((ClockReturn)((*base->wait_async)(gobj(),Glib::unwrap(id)))));
    return retval;
  }

  using RType = ClockReturn;
  return RType();
}
void Gst::Clock::unschedule_vfunc(const Glib::RefPtr<Gst::ClockID>& id) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->unschedule)
  {
    (*base->unschedule)(gobj(),Glib::unwrap(id));
  }
}


} // namespace Gst


