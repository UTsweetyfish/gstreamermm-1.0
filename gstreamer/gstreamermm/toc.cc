// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gstreamermm/toc.h>
#include <gstreamermm/private/toc_p.h>


/*
 * toc.ccg
 *
 *  Created on: Sep 25, 2013
 *      Author: m.kolny
 */
/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2013 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace
{
} // anonymous namespace

// static
GType Glib::Value<Gst::TocScope>::value_type()
{
  return gst_toc_scope_get_type();
}

// static
GType Glib::Value<Gst::TocEntryType>::value_type()
{
  return gst_toc_entry_type_get_type();
}

// static
GType Glib::Value<Gst::TocLoopType>::value_type()
{
  return gst_toc_loop_type_get_type();
}


/* Why reinterpret_cast<Toc*>(gobject) is needed:
 *
 * A Toc instance is in fact always a GstToc instance.
 * Unfortunately, GstToc cannot be a member of Toc,
 * because it is an opaque struct.  Also, the C interface does not provide
 * any hooks to install a destroy notification handler, thus we cannot
 * wrap it dynamically either.
 *
 * The cast works because Toc does not have any member data, and
 * it is impossible to derive from it.  This is ensured by using final on the
 * class and by using = delete on the default constructor.
 */

namespace Glib
{

Glib::RefPtr<Gst::Toc> wrap(GstToc* object, bool take_copy)
{
  if(take_copy && object)
    gst_toc_ref(object);

  // See the comment at the top of this file, if you want to know why the cast works.
  return Glib::RefPtr<Gst::Toc>(reinterpret_cast<Gst::Toc*>(object));
}

} // namespace Glib


namespace Gst
{


void Toc::reference() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  gst_toc_ref(reinterpret_cast<GstToc*>(const_cast<Toc*>(this)));
}

void Toc::unreference() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  gst_toc_unref(reinterpret_cast<GstToc*>(const_cast<Toc*>(this)));
}

GstToc* Toc::gobj()
{
  // See the comment at the top of this file, if you want to know why the cast works.
  return reinterpret_cast<GstToc*>(this);
}

const GstToc* Toc::gobj() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  return reinterpret_cast<const GstToc*>(this);
}

GstToc* Toc::gobj_copy() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  const auto gobject = reinterpret_cast<GstToc*>(const_cast<Toc*>(this));
  gst_toc_ref(gobject);
  return gobject;
}


void Toc::append_entry(Glib::RefPtr<Gst::TocEntry> entry)
{
  gst_toc_append_entry(gobj(), Glib::unwrap(entry));
}

void Toc::dump()
{
  gst_toc_dump(gobj());
}

void Toc::dump() const
{
  return const_cast<Toc*>(this)->dump();
}

void Toc::set_tags(const Gst::TagList& tags)
{
  gst_toc_set_tags(gobj(), const_cast<GstTagList*>(tags.gobj()));
}

Gst::TagList Toc::get_tags() const
{
  return Glib::wrap_taglist(const_cast<GstTagList*>(gst_toc_get_tags(const_cast<GstToc*>(gobj()))), true);
}

Gst::TocScope Toc::get_scope() const
{
  return ((Gst::TocScope)(gst_toc_get_scope(const_cast<GstToc*>(gobj()))));
}

Glib::RefPtr<Gst::TocEntry> Toc::find_entry(const Glib::ustring& uid) const
{
  return Glib::wrap(gst_toc_find_entry(const_cast<GstToc*>(gobj()), uid.c_str()));
}


} // namespace Gst


/* Why reinterpret_cast<TocEntry*>(gobject) is needed:
 *
 * A TocEntry instance is in fact always a GstTocEntry instance.
 * Unfortunately, GstTocEntry cannot be a member of TocEntry,
 * because it is an opaque struct.  Also, the C interface does not provide
 * any hooks to install a destroy notification handler, thus we cannot
 * wrap it dynamically either.
 *
 * The cast works because TocEntry does not have any member data, and
 * it is impossible to derive from it.  This is ensured by using final on the
 * class and by using = delete on the default constructor.
 */

namespace Glib
{

Glib::RefPtr<Gst::TocEntry> wrap(GstTocEntry* object, bool take_copy)
{
  if(take_copy && object)
    gst_toc_entry_ref(object);

  // See the comment at the top of this file, if you want to know why the cast works.
  return Glib::RefPtr<Gst::TocEntry>(reinterpret_cast<Gst::TocEntry*>(object));
}

} // namespace Glib


namespace Gst
{


void TocEntry::reference() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  gst_toc_entry_ref(reinterpret_cast<GstTocEntry*>(const_cast<TocEntry*>(this)));
}

void TocEntry::unreference() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  gst_toc_entry_unref(reinterpret_cast<GstTocEntry*>(const_cast<TocEntry*>(this)));
}

GstTocEntry* TocEntry::gobj()
{
  // See the comment at the top of this file, if you want to know why the cast works.
  return reinterpret_cast<GstTocEntry*>(this);
}

const GstTocEntry* TocEntry::gobj() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  return reinterpret_cast<const GstTocEntry*>(this);
}

GstTocEntry* TocEntry::gobj_copy() const
{
  // See the comment at the top of this file, if you want to know why the cast works.
  const auto gobject = reinterpret_cast<GstTocEntry*>(const_cast<TocEntry*>(this));
  gst_toc_entry_ref(gobject);
  return gobject;
}

TocEntryType TocEntry::get_entry_type()
{
  return ((TocEntryType)(gst_toc_entry_get_entry_type(gobj())));
}

Glib::ustring TocEntry::get_uid()
{
  return Glib::convert_const_gchar_ptr_to_ustring(gst_toc_entry_get_uid(gobj()));
}

void TocEntry::append_sub_entry(Glib::RefPtr<Gst::TocEntry> entry)
{
  gst_toc_entry_append_sub_entry(gobj(), Glib::unwrap(entry));
}

bool TocEntry::is_alternative()
{
  return gst_toc_entry_is_alternative(gobj());
}

bool TocEntry::is_alternative() const
{
  return const_cast<TocEntry*>(this)->is_alternative();
}

bool TocEntry::is_sequence()
{
  return gst_toc_entry_is_sequence(gobj());
}

bool TocEntry::is_sequence() const
{
  return const_cast<TocEntry*>(this)->is_sequence();
}

Glib::RefPtr<Gst::TocEntry> TocEntry::get_parent()
{
  return Glib::wrap(gst_toc_entry_get_parent(gobj()));
}

void TocEntry::set_start_stop_times(gint64 start, gint64 stop)
{
  gst_toc_entry_set_start_stop_times(gobj(), start, stop);
}

bool TocEntry::get_start_stop_times(gint64& start, gint64& stop)
{
  return gst_toc_entry_get_start_stop_times(gobj(), &(start), &(stop));
}

bool TocEntry::get_start_stop_times(gint64& start, gint64& stop) const
{
  return const_cast<TocEntry*>(this)->get_start_stop_times(start, stop);
}

bool TocEntry::get_loop(Gst::TocLoopType& loop_type, gint& repeat_count) const
{
  return gst_toc_entry_get_loop(const_cast<GstTocEntry*>(gobj()), reinterpret_cast<GstTocLoopType*>(&(loop_type)), &(repeat_count));
}

void TocEntry::set_loop(Gst::TocLoopType loop_type, gint repeat_count)
{
  gst_toc_entry_set_loop(gobj(), ((GstTocLoopType)(loop_type)), repeat_count);
}

Glib::RefPtr<Gst::Toc> TocEntry::get_toc() const
{
  return Glib::wrap(gst_toc_entry_get_toc(const_cast<GstTocEntry*>(gobj())));
}


} // namespace Gst


