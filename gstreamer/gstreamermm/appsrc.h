// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!
#ifndef _GSTREAMERMM_APPSRC_H
#define _GSTREAMERMM_APPSRC_H

#include <gstreamermmconfig.h>

#ifndef GSTREAMERMM_DISABLE_DEPRECATED


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

// Generated by generate_plugin_gmmproc_file. Don't edit this file.


#include <gstreamermm/basesrc.h>
#include <gstreamermm/caps.h>
#include <gstreamermm/format.h>
#include <gstreamermm/pad.h>
#include <gstreamermm/buffer.h>
#include <gstreamermm/sample.h>
#include <gstreamermm/urihandler.h>


// Plug-in C enums used in signals:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
using GstAppSrc = struct _GstAppSrc;
using GstAppSrcClass = struct _GstAppSrcClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Gst
{ class AppSrc_Class; } // namespace Gst
#endif //DOXYGEN_SHOULD_SKIP_THIS

namespace Gst
{

/** @addtogroup gstreamermmEnums gstreamermm Enums and Flags */

/** 
 *  @var AppStreamType APP_STREAM_TYPE_STREAM
 * No seeking is supported in the stream, such as a
 * live stream.
 * 
 *  @var AppStreamType APP_STREAM_TYPE_SEEKABLE
 * The stream is seekable but seeking might not
 * be very fast, such as data from a webserver.
 * 
 *  @var AppStreamType APP_STREAM_TYPE_RANDOM_ACCESS
 * The stream is seekable and seeking is fast,
 * such as in a local file.
 * 
 *  @enum AppStreamType
 * 
 * The stream type.
 *
 * @ingroup gstreamermmEnums
 */
enum AppStreamType
{
  APP_STREAM_TYPE_STREAM,
  APP_STREAM_TYPE_SEEKABLE,
  APP_STREAM_TYPE_RANDOM_ACCESS
};

} // namespace Gst

#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::AppStreamType> : public Glib::Value_Enum<Gst::AppStreamType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gst
{


/** A Wrapper for the appsrc plugin.
 * Please note that not all plug-ins are available on all systems so care
 * must be taken that they exist before they are used otherwise there will
 * be errors and possibly a crash.
 *
 * @ingroup GstPlugins
 * @deprecated Plugins API is deprecated, and should not be used in a new code.
 */

class AppSrc
: public Gst::BaseSrc, public Gst::URIHandler
{
  
#ifndef DOXYGEN_SHOULD_SKIP_THIS

public:
  using CppObjectType = AppSrc;
  using CppClassType = AppSrc_Class;
  using BaseObjectType = GstAppSrc;
  using BaseClassType = GstAppSrcClass;

  // noncopyable
  AppSrc(const AppSrc&) = delete;
  AppSrc& operator=(const AppSrc&) = delete;

private:  friend class AppSrc_Class;
  static CppClassType appsrc_class_;

protected:
  explicit AppSrc(const Glib::ConstructParams& construct_params);
  explicit AppSrc(GstAppSrc* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:

  AppSrc(AppSrc&& src) noexcept;
  AppSrc& operator=(AppSrc&& src) noexcept;

  ~AppSrc() noexcept override;

  /** Get the GType for this class, for use with the underlying GObject type system.
   */
  static GType get_type()      G_GNUC_CONST;

#ifndef DOXYGEN_SHOULD_SKIP_THIS


  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GObject.
  GstAppSrc*       gobj()       { return reinterpret_cast<GstAppSrc*>(gobject_); }

  ///Provides access to the underlying C GObject.
  const GstAppSrc* gobj() const { return reinterpret_cast<GstAppSrc*>(gobject_); }

  ///Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.
  GstAppSrc* gobj_copy();

private:

  
protected:
  AppSrc();
  explicit AppSrc(const Glib::ustring& name);

public:
  /** Creates a new appsrc plugin with a unique name.
   */
  
  static Glib::RefPtr<AppSrc> create();


  /** Creates a new appsrc plugin with the given name.
   */
  
  static Glib::RefPtr<AppSrc> create(const Glib::ustring& name);


  /** This is a convenience method for the action signal
   * signal_push_buffer().
   */
  Gst::FlowReturn push_buffer(const Glib::RefPtr<Gst::Buffer>& arg0);

  /** This is a convenience method for the action signal
   * signal_push_sample().
   */
  Gst::FlowReturn push_sample(const Glib::RefPtr<Gst::Sample>& arg0);

  /** This is a convenience method for the action signal
   * signal_end_of_stream().
   */
  Gst::FlowReturn end_of_stream();


  /** The allowed caps for the src pad.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< Glib::RefPtr<Gst::Caps> > property_caps() ;

/** The allowed caps for the src pad.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gst::Caps> > property_caps() const;

  /** The size of the data stream in bytes (-1 if unknown).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< gint64 > property_size() ;

/** The size of the data stream in bytes (-1 if unknown).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< gint64 > property_size() const;

  /** the type of the stream.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< Gst::AppStreamType > property_stream_type() ;

/** the type of the stream.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< Gst::AppStreamType > property_stream_type() const;

  /** The maximum number of bytes to queue internally (0 = unlimited).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< guint64 > property_max_bytes() ;

/** The maximum number of bytes to queue internally (0 = unlimited).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< guint64 > property_max_bytes() const;

  /** The format of the segment events and seek.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< Gst::Format > property_format() ;

/** The format of the segment events and seek.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< Gst::Format > property_format() const;

  /** Block push-buffer when max-bytes are queued.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_block() ;

/** Block push-buffer when max-bytes are queued.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_block() const;

  /** Whether to act as a live source.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_is_live() ;

/** Whether to act as a live source.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_is_live() const;

  /** The minimum latency (-1 = default).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< gint64 > property_min_latency() ;

/** The minimum latency (-1 = default).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< gint64 > property_min_latency() const;

  /** The maximum latency (-1 = unlimited).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< gint64 > property_max_latency() ;

/** The maximum latency (-1 = unlimited).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< gint64 > property_max_latency() const;

  /** Emit need-data, enough-data and seek-data signals.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_emit_signals() ;

/** Emit need-data, enough-data and seek-data signals.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_emit_signals() const;

  /** Emit need-data when queued bytes drops below this percent of max-bytes.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< guint > property_min_percent() ;

/** Emit need-data when queued bytes drops below this percent of max-bytes.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< guint > property_min_percent() const;

  /** The number of currently queued bytes.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< guint64 > property_current_level_bytes() const;


  //gtkmmproc error: duration : property defs lookup failed.

  
  /**
   * @par Slot Prototype:
   * <tt>void on_my_%need_data(guint arg0)</tt>
   *
   * Signal that the source needs more data. In the callback or from another
   * thread you should call push-buffer or end-of-stream.
   * 
   *  @a arg0 is just a hint and when it is set to -1, any number of bytes can be
   * pushed into @a appsrc.
   * 
   * You can call push-buffer multiple times until the enough-data signal is
   * fired.
   * 
   * @param arg0 The amount of bytes needed.
   */

  Glib::SignalProxy< void,guint > signal_need_data();

  
  /**
   * @par Slot Prototype:
   * <tt>void on_my_%enough_data()</tt>
   *
   * Signal that the source has enough data. It is recommended that the
   * application stops calling push-buffer until the need-data signal is
   * emitted again to avoid excessive buffer queueing.
   */

  Glib::SignalProxy< void > signal_enough_data();

  
  /**
   * @par Slot Prototype:
   * <tt>bool on_my_%seek_data(guint64 arg0)</tt>
   *
   * Seek to the given offset. The next push-buffer should produce buffers from
   * the new @a arg0.
   * This callback is only called for seekable stream types.
   * 
   * @param arg0 The offset to seek to.
   * @return <tt>true</tt> if the seek succeeded.
   */

  Glib::SignalProxy< bool,guint64 > signal_seek_data();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, push_buffer().
   *
   * @par Slot Prototype:
   * <tt>Gst::FlowReturn on_my_%push_buffer(const Glib::RefPtr<Gst::Buffer>& arg0)</tt>
   *
   * Adds a buffer to the queue of buffers that the appsrc element will
   * push to its source pad. This function does not take ownership of the
   * buffer so the buffer needs to be unreffed after calling this function.
   * 
   * When the block property is <tt>true</tt>, this function can block until free space
   * becomes available in the queue.
   * 
   * @param arg0 A buffer to push.
   */

  Glib::SignalProxy< Gst::FlowReturn,const Glib::RefPtr<Gst::Buffer>& > signal_push_buffer();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, push_sample().
   *
   * @par Slot Prototype:
   * <tt>Gst::FlowReturn on_my_%push_sample(const Glib::RefPtr<Gst::Sample>& arg0)</tt>
   *
   * Extract a buffer from the provided sample and adds the extracted buffer 
   * to the queue of buffers that the appsrc element will
   * push to its source pad. This function set the appsrc caps based on the caps
   * in the sample and reset the caps if they change. 
   * Only the caps and the buffer of the provided sample are used and not 
   * for example the segment in the sample. 
   * This function does not take ownership of the
   * sample so the sample needs to be unreffed after calling this function.
   * 
   * When the block property is <tt>true</tt>, this function can block until free space
   * becomes available in the queue.
   * 
   * @param arg0 A sample from which extract buffer to push.
   */

  Glib::SignalProxy< Gst::FlowReturn,const Glib::RefPtr<Gst::Sample>& > signal_push_sample();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, end_of_stream().
   *
   * @par Slot Prototype:
   * <tt>Gst::FlowReturn on_my_%end_of_stream()</tt>
   *
   * Notify @a appsrc that no more buffer are available.
   */

  Glib::SignalProxy< Gst::FlowReturn > signal_end_of_stream();


public:

public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


};

} // namespace Gst


namespace Glib
{
  /** A Glib::wrap() method for this object.
   *
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gst::AppSrc
   */
  Glib::RefPtr<Gst::AppSrc> wrap(GstAppSrc* object, bool take_copy = false);
}


#endif // GSTREAMERMM_DISABLE_DEPRECATED


#endif /* _GSTREAMERMM_APPSRC_H */

