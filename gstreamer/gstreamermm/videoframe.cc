// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gstreamermm/videoframe.h>
#include <gstreamermm/private/videoframe_p.h>


/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2015 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
#include <cstring>

namespace Gst
{

VideoFrame::VideoFrame()
{
  std::memset(&gobject_, 0, sizeof(GstVideoFrame));
}

VideoFrame::VideoFrame(const GstVideoFrame* gobject)
{
  if(gobject)
    gobject_ = *gobject;
  else
    std::memset(&gobject_, 0, sizeof(GstVideoFrame));
}
}

namespace
{
} // anonymous namespace

// static
GType Glib::Value<Gst::VideoFrameFlags>::value_type()
{
  return gst_video_frame_flags_get_type();
}

// static
GType Glib::Value<Gst::VideoBufferFlags>::value_type()
{
  return gst_video_buffer_flags_get_type();
}

// static
GType Glib::Value<Gst::VideoFrameMapFlags>::value_type()
{
  return gst_video_frame_map_flags_get_type();
}


namespace Gst
{


bool VideoFrame::map(const Gst::VideoInfo& info, const Glib::RefPtr<Gst::Buffer>& buffer, Gst::MapFlags flags)
{
  return gst_video_frame_map(gobj(), const_cast<GstVideoInfo*>(info.gobj()), Glib::unwrap(buffer), ((GstMapFlags)(flags)));
}

bool VideoFrame::map_id(const Gst::VideoInfo& info, const Glib::RefPtr<Gst::Buffer>& buffer, gint id, Gst::MapFlags flags)
{
  return gst_video_frame_map_id(gobj(), const_cast<GstVideoInfo*>(info.gobj()), Glib::unwrap(buffer), id, ((GstMapFlags)(flags)));
}

void VideoFrame::unmap()
{
  gst_video_frame_unmap(gobj());
}

bool VideoFrame::copy(const Gst::VideoFrame& dest, const Gst::VideoFrame& src)
{
  return gst_video_frame_copy(const_cast<GstVideoFrame*>(dest.gobj()), src.gobj());
}

bool VideoFrame::copy_plane(const Gst::VideoFrame& dest, const Gst::VideoFrame& src, guint plane)
{
  return gst_video_frame_copy_plane(const_cast<GstVideoFrame*>(dest.gobj()), src.gobj(), plane);
}

void VideoFrame::set_info(const Gst::VideoInfo& value)
{
  gobj()->info = *(value.gobj());
}

Gst::VideoInfo VideoFrame::get_info() const
{
  return Gst::VideoInfo(Gst::VideoInfo(const_cast<GstVideoInfo*>(&gobj()->info), false));
}

void VideoFrame::set_flags(const Gst::VideoFrameFlags& value)
{
  gobj()->flags = ((GstVideoFrameFlags)(value));
}

Gst::VideoFrameFlags VideoFrame::get_flags() const
{
  return ((Gst::VideoFrameFlags)(gobj()->flags));
}

void VideoFrame::set_buffer(const Glib::RefPtr<Gst::Buffer>& value)
{
  gobj()->buffer = Glib::unwrap(value);
}

Glib::RefPtr<Gst::Buffer> VideoFrame::get_buffer() const
{
  return Glib::wrap(gobj()->buffer);
}

void VideoFrame::set_meta(const gpointer& value)
{
  gobj()->meta = value;
}

gpointer VideoFrame::get_meta() const
{
  return gobj()->meta;
}

void VideoFrame::set_id(const gint& value)
{
  gobj()->id = value;
}

gint VideoFrame::get_id() const
{
  return gobj()->id;
}


} // namespace Gst


