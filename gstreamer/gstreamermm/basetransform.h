// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!
#ifndef _GSTREAMERMM_BASETRANSFORM_H
#define _GSTREAMERMM_BASETRANSFORM_H


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2016 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/base/gstbasetransform.h>
#include <gstreamermm/element.h>
#include <gstreamermm/pad.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
using GstBaseTransform = struct _GstBaseTransform;
using GstBaseTransformClass = struct _GstBaseTransformClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Gst
{ class BaseTransform_Class; } // namespace Gst
#endif //DOXYGEN_SHOULD_SKIP_THIS

namespace Gst
{

/** A base class for simple transform filters.
 * This base class is for filter elements that process data.
 *
 * It provides for:
 *     - one sinkpad and one srcpad
 *     - Possible formats on sink and source pad implemented with custom
 *     transform_caps_vfunc() function. By default uses same format on sink and
 *     source.
 *     - Handles state changes.
 *     - Does flushing.
 *     - Push mode.
 *     - Pull mode if the sub-class transform_vfunc() can operate on arbitrary
 *     data.
 * 
 * <H3>Use Cases:</H3>
 *    -   <B>1. Passthrough mode</B>
 *           - Element has no interest in modifying the buffer. It may want to
 *           inspect it, in which case the element should have a
 *           transform_ip_vfunc() function. If there is no transform_ip_vfunc()
 *           function in passthrough mode, the buffer is pushed intact.
 *           - On the GstBaseTransformClass is the passthrough_on_same_caps
 *           variable which will automatically set/unset passthrough based on
 *           whether the element negotiates the same caps on both pads.
 *           - passthrough_on_same_caps on an element that doesn't implement a
 *           transform_caps_vfunc() function is useful for elements that only
 *           inspect data (such as level).
 *           .
 *       <B>Example elements</B>
 *           - Level
 *           - VideoScale, AudioConvert, FfmpegColorSpace, AudioResample in
 *           certain modes.
 *       .
 *    -   <B>2. Modifications in-place - input buffer and output buffer are the
 *    same thing.</B>
 *           - The element must implement a transform_ip_vfunc() function.
 *           - Output buffer size must <= input buffer size.
 *           - If the always_in_place flag is set, non-writable buffers will be
 *           copied and passed to the transform_ip_vfunc() function, otherwise
 *           a new buffer will be created and the transform_vfunc() function
 *           called.
 *           - Incoming writable buffers will be passed to the
 *           transform_ip_vfunc() function immediately.
 *           - only implementing transform_ip_vfunc() and not transform_vfunc()
 *           implies always_in_place = TRUE.
 *           .
 *       <B>Example elements</B>
 *           - Volume.
 *           - AudioConvert in certain modes (signed/unsigned conversion).
 *           - FfmpegColorSpace in certain modes (endianness swapping).
 *
 *    -  <B>3. Modifications only to the caps/metadata of a buffer</B>
 *           - The element does not require writable data, but non-writable
 *           buffers should be subbuffered so that the meta-information can be
 *           replaced.
 *           - Elements wishing to operate in this mode should replace the
 *           prepare_output_buffer_vfunc() method to create subbuffers of the
 *           input buffer and set always_in_place to TRUE.
 *           .
 *       <B>Example elements</B>
 *           - CapsFilter when setting caps on outgoing buffers that have none.
 *           - Identity when it is going to re-timestamp buffers by datarate.
 *
 *    -  <B>4. Normal mode</B>
 *           - always_in_place flag is not set, or there is no
 *           transform_ip_vfunc() function.
 *           - Element will receive an input buffer and output buffer to
 *           operate on.
 *           - Output buffer is allocated by calling the
 *           prepare_output_buffer_vfunc() function.
 *           .
 *       <B>Example elements</B>
 *           - VideoScale, FfmpegColorSpace, AudioConvert when doing
 *           scaling/conversions.
 *
 *    -  <B>5. Special output buffer allocations</B>
 *           - Elements which need to do special allocation of their output
 *           buffers other than what Gst::Pad::alloc_buffer() allows should
 *           implement a prepare_output_buffer_vfunc() method, which calls the
 *           parent implementation and passes the newly allocated buffer. 
 *           .
 *       <B>Example elements</B>
 *           - Efence.
 * 
 * <B>Sub-class settable flags on Gst::BaseTransform</B>
 * 
 *     - <B>passthrough</B>
 *           - Implies that in the current configuration, the sub-class is not
 *           interested in modifying the buffers.
 *           - Elements which are always in passthrough mode whenever the same
 *           caps has been negotiated on both pads can set the class variable
 *           passthrough_on_same_caps to have this behaviour automatically.
 *           .
 *     - <B>always_in_place</B>
 *           - Determines whether a non-writable buffer will be copied before
 *           passing to the transform_ip function.
 *           - Implied TRUE if no transform function is implemented.
 *           - Implied FALSE if ONLY transform function is implemented.
 *
 * Last reviewed on 2016-05-16 (1.8.0).
 *
 * @ingroup GstBaseClasses
**/

class BaseTransform
: public Element
{
  
#ifndef DOXYGEN_SHOULD_SKIP_THIS

public:
  using CppObjectType = BaseTransform;
  using CppClassType = BaseTransform_Class;
  using BaseObjectType = GstBaseTransform;
  using BaseClassType = GstBaseTransformClass;

  // noncopyable
  BaseTransform(const BaseTransform&) = delete;
  BaseTransform& operator=(const BaseTransform&) = delete;

private:  friend class BaseTransform_Class;
  static CppClassType basetransform_class_;

protected:
  explicit BaseTransform(const Glib::ConstructParams& construct_params);
  explicit BaseTransform(GstBaseTransform* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:

  BaseTransform(BaseTransform&& src) noexcept;
  BaseTransform& operator=(BaseTransform&& src) noexcept;

  ~BaseTransform() noexcept override;

  /** Get the GType for this class, for use with the underlying GObject type system.
   */
  static GType get_type()      G_GNUC_CONST;

#ifndef DOXYGEN_SHOULD_SKIP_THIS


  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GObject.
  GstBaseTransform*       gobj()       { return reinterpret_cast<GstBaseTransform*>(gobject_); }

  ///Provides access to the underlying C GObject.
  const GstBaseTransform* gobj() const { return reinterpret_cast<GstBaseTransform*>(gobject_); }

  ///Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.
  GstBaseTransform* gobj_copy();

private:


public:
  /** The name of the templates for the sink pad ("sink").
   */
  static const Glib::ustring SINK_NAME;

  /** The name of the templates for the source pad ("src").
   */
  static const Glib::ustring SRC_NAME;

  /** A Gst::FlowReturn that can be returned from transform_vfunc and transform_ip_vfunc
   * to indicate that no output buffer was generated.
   */
  static constexpr Gst::FlowReturn FLOW_DROPPED = static_cast<Gst::FlowReturn>(GST_BASE_TRANSFORM_FLOW_DROPPED);

  
  /** See if @a trans is configured as a passthrough transform.
   * 
   * @return <tt>true</tt> is the transform is configured in passthrough mode.
   * 
   * MT safe.
   */
  bool is_passthrough() const;
  
  /** Set passthrough mode for this filter by default. This is mostly
   * useful for filters that do not care about negotiation.
   * 
   * Always <tt>true</tt> for filters which don't implement either a transform
   * or transform_ip method.
   * 
   * MT safe.
   * 
   * @param passthrough Boolean indicating passthrough mode.
   */
  void set_passthrough(bool passthrough);
  
  /** See if @a trans is configured as a in_place transform.
   * 
   * @return <tt>true</tt> is the transform is configured in in_place mode.
   * 
   * MT safe.
   */
  bool is_in_place() const;
  
  /** Determines whether a non-writable buffer will be copied before passing
   * to the transform_ip function.
   * - Always <tt>true</tt> if no transform function is implemented.
   * - Always <tt>false</tt> if ONLY transform function is implemented.
   * 
   * MT safe.
   * 
   * @param in_place Boolean value indicating that we would like to operate
   * on in_place buffers.
   */
  void set_in_place(bool in_place);
  
  /** Queries if the transform will handle QoS.
   * 
   * @return <tt>true</tt> if QoS is enabled.
   * 
   * MT safe.
   */
  bool is_qos_enabled() const;
  
  /** Enable or disable QoS handling in the transform.
   * 
   * MT safe.
   * 
   * @param enabled New state.
   */
  void set_qos_enabled(bool enabled);
  
  /** Set the QoS parameters in the transform. This function is called internally
   * when a QOS event is received but subclasses can provide custom information
   * when needed.
   * 
   * MT safe.
   * 
   * @param proportion The proportion.
   * @param diff The diff against the clock.
   * @param timestamp The timestamp of the buffer generating the QoS expressed in
   * running_time.
   */
  void update_qos(double proportion, Gst::ClockTimeDiff diff, Gst::ClockTime timestamp);
  
  /** If @a gap_aware is <tt>false</tt> (the default), output buffers will have the
   * Gst::BUFFER_FLAG_GAP flag unset.
   * 
   * If set to <tt>true</tt>, the element must handle output buffers with this flag set
   * correctly, i.e. it can assume that the buffer contains neutral data but must
   * unset the flag if the output is no neutral data.
   * 
   * MT safe.
   * 
   * @param gap_aware New state.
   */
  void set_gap_aware(bool gap_aware);
  
  /** Instructs @a trans to request renegotiation upstream. This function is
   * typically called after properties on the transform were set that
   * influence the input format.
   */
  void reconfigure_sink();
  
  /** Instructs @a trans to renegotiate a new downstream transform on the next
   * buffer. This function is typically called after properties on the transform
   * were set that influence the output format.
   */
  void reconfigure_src();
  
  /** If @a prefer_passthrough is <tt>true</tt> (the default), @a trans will check and
   * prefer passthrough caps from the list of caps returned by the
   * transform_caps vmethod.
   * 
   * If set to <tt>false</tt>, the element must order the caps returned from the
   * transform_caps function in such a way that the preferred format is
   * first in the list. This can be interesting for transforms that can do
   * passthrough transforms but prefer to do something else, like a
   * capsfilter.
   * 
   * MT safe.
   * 
   * @param prefer_passthrough New state.
   */
  void set_prefer_passthrough(bool prefer_passthrough);
  
  /** Updates the srcpad caps and send the caps downstream. This function
   * can be used by subclasses when they have already negotiated their caps
   * but found a change in them (or computed new informations). This way,
   * they can notify downstream about that change without loosing any
   * buffer.
   * 
   * @param updated_caps An updated version of the srcpad caps to be pushed
   * downstream.
   * @return <tt>true</tt> if the caps could be send downstream <tt>false</tt> otherwise.
   */
  bool update_src_caps(const Glib::RefPtr<Gst::Caps>& updated_caps);

  /* Return the memory @allocator used by the base class and its @a params.
   * @param params The Gst::AllocationParams of the allocator.
   * @return A Gst::Allocator used.
   */
  Glib::RefPtr<Gst::Allocator> get_allocator(Gst::AllocationParams& params);
  

  /** Gives the refptr to the sink Gst::Pad object of the element.
   */
  Glib::RefPtr<Gst::Pad> get_sink_pad();
  Glib::RefPtr<const Gst::Pad> get_sink_pad() const;

  /** Gives the refptr to the source Gst::Pad object of the element.
   */
  Glib::RefPtr<Gst::Pad> get_src_pad();
  Glib::RefPtr<const Gst::Pad> get_src_pad() const;

  /** Handle Quality-of-Service events.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_qos() ;

/** Handle Quality-of-Service events.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_qos() const;


  /** Optional. Given the pad in this direction and the given caps, what caps
   * are allowed on the other pad in this element ?
   */
    virtual Glib::RefPtr<Gst::Caps> transform_caps_vfunc(PadDirection direction, const Glib::RefPtr<Gst::Caps>& caps, const Glib::RefPtr<Gst::Caps>& filter);


  /** Optional. Given the pad in this direction and the given caps, fixate the
   * caps on the other pad.
   */
    virtual Glib::RefPtr<Gst::Caps> fixate_caps_vfunc(PadDirection direction, const Glib::RefPtr<Gst::Caps>& caps, const Glib::RefPtr<Gst::Caps>& othercaps);


  //TODO: This virtual function can't be wrapped without causing execution
  //errors with the ogg_player_gtkmm example.
  ///** Optional. Given the size of a buffer in the given direction with the
   //* given caps, calculate the size in bytes of a buffer on the other pad with
   //* the given other caps. The default implementation uses
   //* get_unit_size_vfunc() and keeps the number of units the same.
   //*/
  //_WRAP_VFUNC(bool transform_size(PadDirection direction, const Glib::RefPtr<Gst::Caps>& caps, guint size, const Glib::RefPtr<Gst::Caps>& othercaps, guint& othersize), "transform_size")

  /** Required if the transform is not in-place. Get the size in bytes of one
   * unit for the given caps.
   */
    virtual bool get_unit_size_vfunc(const Glib::RefPtr<Gst::Caps>& caps, gsize& size) const;


  /** Allows the subclass to be notified of the actual caps set.
   */
    virtual bool set_caps_vfunc(const Glib::RefPtr<Gst::Caps>& incaps, const Glib::RefPtr<Gst::Caps>& outcaps);


  /** Required if the element does not operate in-place. Transforms one
   * incoming buffer to one outgoing buffer. The function is allowed to change
   * size/timestamp/duration of the outgoing buffer.
   */
    virtual FlowReturn transform_vfunc(const Glib::RefPtr<Gst::Buffer>& inbuf, const Glib::RefPtr<Gst::Buffer>& outbuf);

  /** Required if the element operates in-place. Transform the incoming buffer
   * in-place.
   */
    virtual FlowReturn transform_ip_vfunc(const Glib::RefPtr<Gst::Buffer>& buf);


  /** Optional. Subclasses can override this to do their own allocation of
   * output buffers. Elements that only do analysis can return a subbuffer or
   * even just increment the reference to the input buffer (if in passthrough
   * mode).
   */
  virtual FlowReturn prepare_output_buffer_vfunc(const Glib::RefPtr<Gst::Buffer>& input, Glib::RefPtr<Gst::Buffer>& buffer);

  /** Optional. Event handler on the source pad. The default implementation
   * handles the event and forwards it downstream.
   */
    virtual bool src_event_vfunc(const Glib::RefPtr<Gst::Event>& event);


  /** Optional. Event handler on the sink pad. The default implementation handles
   * the event and forwards it downstream.
   */
    virtual bool sink_event_vfunc(const Glib::RefPtr<Gst::Event>& event);


  /** Optional. This method is called right before the base class
   * will start processing. Dynamic properties or other delayed configuration
   * could be performed in this method.
   */
    virtual void before_transform_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer);


  /** Optional. Subclasses can override this method to check if
   * the caps can be handled by the element. The default implementation might
   * not be the most optimal way to check this in all cases.
   */
    virtual bool accept_caps_vfunc(PadDirection direction, const Glib::RefPtr<const Gst::Caps>& caps);


  /** Optional. Called when the element starts processing. Allows opening
   * external resources.
   */
    virtual bool start_vfunc();


  /** Optional. Called when the element starts processing. Allows opening
   * external resources.
   */
    virtual bool stop_vfunc();


  /** Setup the allocation parameters for allocating output buffers. The passed
   * in query contains the result of the downstream allocation query.This function
   * is only called when not operating in passthrough mode. The default implementation
   * will remove all memory dependent metadata. If there is a filter_meta method
   * implementation, it will be called for all metadata API in the downstream query,
   * otherwise the metadata API is removed.
   */
  virtual bool decide_allocation_vfunc(const Glib::RefPtr<Gst::Query>& query);

  /** Return TRUE if the metadata API should be proposed in the upstream allocation query.
   * The default implementation is NULL and will cause all metadata to be removed.
   */
    virtual bool filter_meta_vfunc(const Glib::RefPtr<Gst::Query>& query, GType api, const Gst::Structure& params);


  /** Propose buffer allocation parameters for upstream elements. This function must
   * be implemented if the element reads or writes the buffer content.
   * The query that was passed to the decide_allocation is passed in this method (or nullptr
   * when the element is in passthrough mode). The default implementation will pass the
   * query downstream when in passthrough mode and will copy all the filtered metadata API
   * in non-passthrough mode.
   */
  virtual bool propose_allocation_vfunc(const Glib::RefPtr<Gst::Query>& decide_query, const Glib::RefPtr<Gst::Query>& query);

   
  /** Function which accepts a new input buffer and pre-processes it. The default
   * implementation performs caps (re)negotiation, then QoS if needed, and places
   * the input buffer into the queued_buf member variable. If the buffer is dropped
   * due to QoS, it returns Gst::BASE_TRANSFORM_FLOW_DROPPED. If this input buffer
   * is not contiguous with any previous input buffer, then is_discont is set to TRUE.
   */
    virtual Gst::FlowReturn submit_input_buffer_vfunc(bool is_discont, const Glib::RefPtr<Gst::Buffer>& input);


  /** Called after each new input buffer is submitted repeatedly until it either generates
   * an error or fails to generate an output buffer. The default implementation takes the
   * contents of the queued_buf variable, generates an output buffer if needed by calling
   * the class prepare_output_buffer, and then calls either transform or transform_ip.
   * Elements that don't do 1-to-1 transformations on input to output buffers can either
   * return Gst::BASE_TRANSFORM_FLOW_DROPPED or simply not generate an output buffer until
   * they are ready to do so.
   */
  virtual Gst::FlowReturn generate_output_vfunc(Glib::RefPtr<Gst::Buffer>& buffer);

  // TODO: wrap GstMeta first.
  //_WRAP_VFUNC(bool transform_meta(const Glib::RefPtr<Gst::Buffer>& outbuf, const Glib::RefPtr<Gst::Meta>& meta, const Glib::RefPtr<Gst::Buffer>& inbuf), "transform_meta")

  /** Optional. Copy the metadata from the input buffer to the output buffer.
   * The default implementation will copy the flags, timestamps and offsets of the buffer.
   */
    virtual bool copy_metadata_vfunc(const Glib::RefPtr<Gst::Buffer>& input, const Glib::RefPtr<Gst::Buffer>& outbuf);


  /** Optional. Handle a requested query. Subclasses that implement this should must chain up to
   * the parent if they didn't handle the query
   */
  bool base_transform_query_vfunc(Gst::PadDirection direction, const Glib::RefPtr<Gst::Query>& query);

protected:

  
public:

public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


};

} //namespace Gst


namespace Glib
{
  /** A Glib::wrap() method for this object.
   *
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gst::BaseTransform
   */
  Glib::RefPtr<Gst::BaseTransform> wrap(GstBaseTransform* object, bool take_copy = false);
}


#endif /* _GSTREAMERMM_BASETRANSFORM_H */

