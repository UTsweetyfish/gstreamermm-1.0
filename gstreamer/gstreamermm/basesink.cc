// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gstreamermm/basesink.h>
#include <gstreamermm/private/basesink_p.h>


/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2016 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


#define IGNORE_RESULT(x) { auto release_value = x; (void)release_value; }

namespace Gst {

gboolean BaseSink_Class::query_vfunc_callback(GstBaseSink* self, GstQuery* query)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        auto qurery_wrapper = Glib::wrap(query, false);
        int retval = static_cast<int>(obj->base_sink_query_vfunc(qurery_wrapper));
        IGNORE_RESULT(qurery_wrapper.release());
        return retval;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->query)
  {
    gboolean retval = (*base->query)(self, query);
    return retval;
  }

  typedef gboolean RType;
  return RType();
}

bool Gst::BaseSink::base_sink_query_vfunc(const Glib::RefPtr<Gst::Query>& query)
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->query)
    {
    bool retval((*base->query)(gobj(),Glib::unwrap(query)));
    return retval;
  }

  typedef bool RType;
  return RType();
}


}

namespace
{
} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Gst::BaseSink> wrap(GstBaseSink* object, bool take_copy)
{
  return Glib::RefPtr<Gst::BaseSink>( dynamic_cast<Gst::BaseSink*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gst
{


/* The *_Class implementation: */

const Glib::Class& BaseSink_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &BaseSink_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gst_base_sink_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void BaseSink_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

  klass->get_caps = &get_caps_vfunc_callback;
  klass->set_caps = &set_caps_vfunc_callback;
  klass->get_times = &get_times_vfunc_callback;
  klass->start = &start_vfunc_callback;
  klass->stop = &stop_vfunc_callback;
  klass->unlock = &unlock_vfunc_callback;
  klass->event = &event_vfunc_callback;
  klass->wait_event = &wait_event_vfunc_callback;
  klass->preroll = &preroll_vfunc_callback;
  klass->render = &render_vfunc_callback;
  klass->activate_pull = &activate_pull_vfunc_callback;
  klass->fixate = &fixate_vfunc_callback;
  klass->unlock_stop = &unlock_stop_vfunc_callback;
  klass->render_list = &render_list_vfunc_callback;
  klass->prepare = &prepare_vfunc_callback;
  klass->prepare_list = &prepare_list_vfunc_callback;
  klass->propose_allocation = &propose_allocation_vfunc_callback;
  klass->query = &query_vfunc_callback;
  
}

GstCaps* BaseSink_Class::get_caps_vfunc_callback(GstBaseSink* self, GstCaps* filter)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return Glib::unwrap_copy(obj->get_caps_vfunc(Glib::wrap(filter, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->get_caps)
    return (*base->get_caps)(self, filter);

  using RType = GstCaps*;
  return RType();
}
gboolean BaseSink_Class::set_caps_vfunc_callback(GstBaseSink* self, GstCaps* caps)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->set_caps_vfunc(Glib::wrap(caps, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->set_caps)
    return (*base->set_caps)(self, caps);

  return static_cast<int>(true);
}
void BaseSink_Class::get_times_vfunc_callback(GstBaseSink* self, GstBuffer* buffer, GstClockTime* start, GstClockTime* end)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        obj->get_times_vfunc(Glib::wrap(buffer, true)
, *(start)
, *(end)
);
        return;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->get_times)
    (*base->get_times)(self, buffer, start, end);
}
gboolean BaseSink_Class::start_vfunc_callback(GstBaseSink* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->start_vfunc());
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->start)
    return (*base->start)(self);

  return static_cast<int>(true);
}
gboolean BaseSink_Class::stop_vfunc_callback(GstBaseSink* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->stop_vfunc());
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->stop)
    return (*base->stop)(self);

  return static_cast<int>(true);
}
gboolean BaseSink_Class::unlock_vfunc_callback(GstBaseSink* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->unlock_vfunc());
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->unlock)
    return (*base->unlock)(self);

  return static_cast<int>(true);
}
gboolean BaseSink_Class::event_vfunc_callback(GstBaseSink* self, GstEvent* event)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->event_vfunc(Glib::wrap(event, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->event)
    return (*base->event)(self, event);

  return static_cast<int>(true);
}
GstFlowReturn BaseSink_Class::wait_event_vfunc_callback(GstBaseSink* self, GstEvent* event)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstFlowReturn)(obj->wait_event_vfunc(Glib::wrap(event, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->wait_event)
    return (*base->wait_event)(self, event);

  using RType = GstFlowReturn;
  return RType();
}
GstFlowReturn BaseSink_Class::preroll_vfunc_callback(GstBaseSink* self, GstBuffer* buffer)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstFlowReturn)(obj->preroll_vfunc(Glib::wrap(buffer, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->preroll)
    return (*base->preroll)(self, buffer);

  using RType = GstFlowReturn;
  return RType();
}
GstFlowReturn BaseSink_Class::render_vfunc_callback(GstBaseSink* self, GstBuffer* buffer)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstFlowReturn)(obj->render_vfunc(Glib::wrap(buffer, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->render)
    return (*base->render)(self, buffer);

  using RType = GstFlowReturn;
  return RType();
}
gboolean BaseSink_Class::activate_pull_vfunc_callback(GstBaseSink* self, gboolean active)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->activate_pull_vfunc(active
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->activate_pull)
    return (*base->activate_pull)(self, active);

  return static_cast<int>(true);
}
GstCaps* BaseSink_Class::fixate_vfunc_callback(GstBaseSink* self, GstCaps* caps)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return Glib::unwrap_copy(obj->fixate_vfunc(Glib::wrap(caps, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->fixate)
    return (*base->fixate)(self, caps);

  using RType = GstCaps*;
  return RType();
}
gboolean BaseSink_Class::unlock_stop_vfunc_callback(GstBaseSink* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->unlock_stop_vfunc());
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->unlock_stop)
    return (*base->unlock_stop)(self);

  return static_cast<int>(true);
}
GstFlowReturn BaseSink_Class::render_list_vfunc_callback(GstBaseSink* self, GstBufferList* buffer_list)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstFlowReturn)(obj->render_list_vfunc(Glib::wrap(buffer_list, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->render_list)
    return (*base->render_list)(self, buffer_list);

  using RType = GstFlowReturn;
  return RType();
}
GstFlowReturn BaseSink_Class::prepare_vfunc_callback(GstBaseSink* self, GstBuffer* buffer)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstFlowReturn)(obj->prepare_vfunc(Glib::wrap(buffer, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->prepare)
    return (*base->prepare)(self, buffer);

  using RType = GstFlowReturn;
  return RType();
}
GstFlowReturn BaseSink_Class::prepare_list_vfunc_callback(GstBaseSink* self, GstBufferList* buffer_list)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstFlowReturn)(obj->prepare_list_vfunc(Glib::wrap(buffer_list, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->prepare_list)
    return (*base->prepare_list)(self, buffer_list);

  using RType = GstFlowReturn;
  return RType();
}
gboolean BaseSink_Class::propose_allocation_vfunc_callback(GstBaseSink* self, GstQuery* query)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->propose_allocation_vfunc(Glib::wrap(query, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->propose_allocation)
    return (*base->propose_allocation)(self, query);

  using RType = gboolean;
  return RType();
}


Glib::ObjectBase* BaseSink_Class::wrap_new(GObject* object)
{
  return new BaseSink((GstBaseSink*)object);
}


/* The implementation: */

GstBaseSink* BaseSink::gobj_copy()
{
  reference();
  return gobj();
}

BaseSink::BaseSink(const Glib::ConstructParams& construct_params)
:
  Element(construct_params)
{

}

BaseSink::BaseSink(GstBaseSink* castitem)
:
  Element((GstElement*)(castitem))
{}


BaseSink::BaseSink(BaseSink&& src) noexcept
: Element(std::move(src))
{}

BaseSink& BaseSink::operator=(BaseSink&& src) noexcept
{
  Element::operator=(std::move(src));
  return *this;
}


BaseSink::~BaseSink() noexcept
{}


BaseSink::CppClassType BaseSink::basesink_class_; // initialize static member

GType BaseSink::get_type()
{
  return basesink_class_.init().get_type();
}


GType BaseSink::get_base_type()
{
  return gst_base_sink_get_type();
}


bool BaseSink::query_latency(bool& live, bool& upstream_live, Gst::ClockTime& min_latency, Gst::ClockTime& max_latency) const
{
  return gst_base_sink_query_latency(const_cast<GstBaseSink*>(gobj()), ((gboolean*) &(live)), ((gboolean*) &(upstream_live)), (GstClockTime*)(&min_latency), (GstClockTime*)(&max_latency));
}

Gst::ClockTime BaseSink::get_latency() const
{
  return ((Gst::ClockTime)(gst_base_sink_get_latency(const_cast<GstBaseSink*>(gobj()))));
}

Gst::FlowReturn BaseSink::do_preroll(const Glib::RefPtr<Gst::MiniObject>& obj)
{
  return ((Gst::FlowReturn)(gst_base_sink_do_preroll(gobj(), Glib::unwrap(obj))));
}

Gst::FlowReturn BaseSink::wait_preroll()
{
  return ((Gst::FlowReturn)(gst_base_sink_wait_preroll(gobj())));
}

Gst::ClockReturn BaseSink::wait_clock(Gst::ClockTime time, Gst::ClockTimeDiff& jitter)
{
  return ((Gst::ClockReturn)(gst_base_sink_wait_clock(gobj(), ((GstClockTime)(time)), (GstClockTimeDiff*)(&jitter))));
}

Gst::ClockReturn BaseSink::wait_clock(Gst::ClockTime time)
{
  return ((Gst::ClockReturn)(gst_base_sink_wait_clock(gobj(), ((GstClockTime)(time)), nullptr)));
}

Gst::FlowReturn BaseSink::wait(Gst::ClockTime time, Gst::ClockTimeDiff& jitter)
{
  return ((Gst::FlowReturn)(gst_base_sink_wait(gobj(), ((GstClockTime)(time)), (GstClockTimeDiff*)(&jitter))));
}

Gst::FlowReturn BaseSink::wait(Gst::ClockTime time)
{
  return ((Gst::FlowReturn)(gst_base_sink_wait(gobj(), ((GstClockTime)(time)), nullptr)));
}

void BaseSink::set_sync(bool sync)
{
  gst_base_sink_set_sync(gobj(), static_cast<int>(sync));
}

bool BaseSink::get_sync() const
{
  return gst_base_sink_get_sync(const_cast<GstBaseSink*>(gobj()));
}

void BaseSink::set_max_lateness(gint64 max_lateness)
{
  gst_base_sink_set_max_lateness(gobj(), max_lateness);
}

gint64 BaseSink::get_max_lateness() const
{
  return gst_base_sink_get_max_lateness(const_cast<GstBaseSink*>(gobj()));
}

void BaseSink::set_qos_enabled(bool enabled)
{
  gst_base_sink_set_qos_enabled(gobj(), static_cast<int>(enabled));
}

bool BaseSink::is_qos_enabled() const
{
  return gst_base_sink_is_qos_enabled(const_cast<GstBaseSink*>(gobj()));
}

void BaseSink::set_async_enabled(bool enabled)
{
  gst_base_sink_set_async_enabled(gobj(), static_cast<int>(enabled));
}

bool BaseSink::is_async_enabled() const
{
  return gst_base_sink_is_async_enabled(const_cast<GstBaseSink*>(gobj()));
}

void BaseSink::set_ts_offset(Gst::ClockTimeDiff offset)
{
  gst_base_sink_set_ts_offset(gobj(), GstClockTimeDiff(offset));
}

Gst::ClockTimeDiff BaseSink::get_ts_offset() const
{
  return Gst::ClockTimeDiff(gst_base_sink_get_ts_offset(const_cast<GstBaseSink*>(gobj())));
}

void BaseSink::set_render_delay(Gst::ClockTime delay)
{
  gst_base_sink_set_render_delay(gobj(), ((GstClockTime)(delay)));
}

Gst::ClockTime BaseSink::get_render_delay() const
{
  return ((Gst::ClockTime)(gst_base_sink_get_render_delay(const_cast<GstBaseSink*>(gobj()))));
}

void BaseSink::set_blocksize(guint blocksize)
{
  gst_base_sink_set_blocksize(gobj(), blocksize);
}

guint BaseSink::get_blocksize() const
{
  return gst_base_sink_get_blocksize(const_cast<GstBaseSink*>(gobj()));
}

guint64 BaseSink::get_throttle_time() const
{
  return gst_base_sink_get_throttle_time(const_cast<GstBaseSink*>(gobj()));
}

void BaseSink::set_throttle_time(guint64 throttle)
{
  gst_base_sink_set_throttle_time(gobj(), throttle);
}

Glib::RefPtr<Gst::Sample> BaseSink::get_last_sample() const
{
  return Glib::wrap(gst_base_sink_get_last_sample(const_cast<GstBaseSink*>(gobj())));
}

void BaseSink::set_max_bitrate(guint64 max_bitrate)
{
  gst_base_sink_set_max_bitrate(gobj(), max_bitrate);
}

guint64 BaseSink::get_max_bitrate() const
{
  return gst_base_sink_get_max_bitrate(const_cast<GstBaseSink*>(gobj()));
}

void BaseSink::set_last_sample_enabled(bool enabled)
{
  gst_base_sink_set_last_sample_enabled(gobj(), static_cast<int>(enabled));
}

bool BaseSink::is_last_sample_enabled() const
{
  return gst_base_sink_is_last_sample_enabled(const_cast<GstBaseSink*>(gobj()));
}

Glib::RefPtr<Gst::Pad> BaseSink::get_sink_pad()
{
  Glib::RefPtr<Gst::Pad> ref_ptr(Glib::wrap(gobj()->sinkpad));

  if(ref_ptr)
    ref_ptr->reference();

  return ref_ptr;
}

Glib::RefPtr<const Gst::Pad> BaseSink::get_sink_pad() const
{
  Glib::RefPtr<const Gst::Pad> ref_ptr(Glib::wrap(gobj()->sinkpad));

  if(ref_ptr)
    ref_ptr->reference();

  return ref_ptr;
}


Glib::PropertyProxy< bool > BaseSink::property_async() 
{
  return Glib::PropertyProxy< bool >(this, "async");
}

Glib::PropertyProxy_ReadOnly< bool > BaseSink::property_async() const
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "async");
}

Glib::PropertyProxy< gint64 > BaseSink::property_max_lateness() 
{
  return Glib::PropertyProxy< gint64 >(this, "max-lateness");
}

Glib::PropertyProxy_ReadOnly< gint64 > BaseSink::property_max_lateness() const
{
  return Glib::PropertyProxy_ReadOnly< gint64 >(this, "max-lateness");
}

Glib::PropertyProxy< bool > BaseSink::property_qos() 
{
  return Glib::PropertyProxy< bool >(this, "qos");
}

Glib::PropertyProxy_ReadOnly< bool > BaseSink::property_qos() const
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "qos");
}

Glib::PropertyProxy< bool > BaseSink::property_sync() 
{
  return Glib::PropertyProxy< bool >(this, "sync");
}

Glib::PropertyProxy_ReadOnly< bool > BaseSink::property_sync() const
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "sync");
}

Glib::PropertyProxy< gint64 > BaseSink::property_ts_offset() 
{
  return Glib::PropertyProxy< gint64 >(this, "ts-offset");
}

Glib::PropertyProxy_ReadOnly< gint64 > BaseSink::property_ts_offset() const
{
  return Glib::PropertyProxy_ReadOnly< gint64 >(this, "ts-offset");
}

Glib::PropertyProxy< guint64 > BaseSink::property_render_delay() 
{
  return Glib::PropertyProxy< guint64 >(this, "render-delay");
}

Glib::PropertyProxy_ReadOnly< guint64 > BaseSink::property_render_delay() const
{
  return Glib::PropertyProxy_ReadOnly< guint64 >(this, "render-delay");
}

Glib::PropertyProxy< guint64 > BaseSink::property_throttle_time() 
{
  return Glib::PropertyProxy< guint64 >(this, "throttle-time");
}

Glib::PropertyProxy_ReadOnly< guint64 > BaseSink::property_throttle_time() const
{
  return Glib::PropertyProxy_ReadOnly< guint64 >(this, "throttle-time");
}

Glib::PropertyProxy< guint > BaseSink::property_blocksize() 
{
  return Glib::PropertyProxy< guint >(this, "blocksize");
}

Glib::PropertyProxy_ReadOnly< guint > BaseSink::property_blocksize() const
{
  return Glib::PropertyProxy_ReadOnly< guint >(this, "blocksize");
}

Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gst::Sample> > BaseSink::property_last_sample() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gst::Sample> >(this, "last-sample");
}

Glib::PropertyProxy< bool > BaseSink::property_enable_last_sample() 
{
  return Glib::PropertyProxy< bool >(this, "enable-last-sample");
}

Glib::PropertyProxy_ReadOnly< bool > BaseSink::property_enable_last_sample() const
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "enable-last-sample");
}

Glib::PropertyProxy< guint64 > BaseSink::property_max_bitrate() 
{
  return Glib::PropertyProxy< guint64 >(this, "max-bitrate");
}

Glib::PropertyProxy_ReadOnly< guint64 > BaseSink::property_max_bitrate() const
{
  return Glib::PropertyProxy_ReadOnly< guint64 >(this, "max-bitrate");
}


Glib::RefPtr<Gst::Caps> Gst::BaseSink::get_caps_vfunc(const Glib::RefPtr<Gst::Caps>& caps) const
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->get_caps)
  {
    Glib::RefPtr<Gst::Caps> retval(Glib::wrap((*base->get_caps)(const_cast<GstBaseSink*>(gobj()),Glib::unwrap(caps))));
    return retval;
  }

  using RType = Glib::RefPtr<Gst::Caps>;
  return RType();
}
bool Gst::BaseSink::set_caps_vfunc(const Glib::RefPtr<Gst::Caps>& caps) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->set_caps)
  {
    bool retval((*base->set_caps)(gobj(),Glib::unwrap(caps)));
    return retval;
  }

  return true;
}
void Gst::BaseSink::get_times_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer, Gst::ClockTime& start, Gst::ClockTime& end) const
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->get_times)
  {
    (*base->get_times)(const_cast<GstBaseSink*>(gobj()),Glib::unwrap(buffer),(GstClockTime*)(&start),(GstClockTime*)(&end));
  }
}
bool Gst::BaseSink::start_vfunc() 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->start)
  {
    bool retval((*base->start)(gobj()));
    return retval;
  }

  return true;
}
bool Gst::BaseSink::stop_vfunc() 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->stop)
  {
    bool retval((*base->stop)(gobj()));
    return retval;
  }

  return true;
}
bool Gst::BaseSink::unlock_vfunc() 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->unlock)
  {
    bool retval((*base->unlock)(gobj()));
    return retval;
  }

  return true;
}
bool Gst::BaseSink::event_vfunc(const Glib::RefPtr<Gst::Event>& event) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->event)
  {
    bool retval((*base->event)(gobj(),Glib::unwrap(event)));
    return retval;
  }

  return true;
}
FlowReturn Gst::BaseSink::wait_event_vfunc(const Glib::RefPtr<Gst::Event>& event) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->wait_event)
  {
    FlowReturn retval(((FlowReturn)((*base->wait_event)(gobj(),Glib::unwrap(event)))));
    return retval;
  }

  using RType = FlowReturn;
  return RType();
}
FlowReturn Gst::BaseSink::preroll_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->preroll)
  {
    FlowReturn retval(((FlowReturn)((*base->preroll)(gobj(),Glib::unwrap(buffer)))));
    return retval;
  }

  using RType = FlowReturn;
  return RType();
}
FlowReturn Gst::BaseSink::render_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->render)
  {
    FlowReturn retval(((FlowReturn)((*base->render)(gobj(),Glib::unwrap(buffer)))));
    return retval;
  }

  using RType = FlowReturn;
  return RType();
}
bool Gst::BaseSink::activate_pull_vfunc(bool active) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->activate_pull)
  {
    bool retval((*base->activate_pull)(gobj(),static_cast<int>(active)));
    return retval;
  }

  return true;
}
Glib::RefPtr<Gst::Caps> Gst::BaseSink::fixate_vfunc(const Glib::RefPtr<Gst::Caps>& caps) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->fixate)
  {
    Glib::RefPtr<Gst::Caps> retval(Glib::wrap((*base->fixate)(gobj(),Glib::unwrap(caps))));
    return retval;
  }

  using RType = Glib::RefPtr<Gst::Caps>;
  return RType();
}
bool Gst::BaseSink::unlock_stop_vfunc() 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->unlock_stop)
  {
    bool retval((*base->unlock_stop)(gobj()));
    return retval;
  }

  return true;
}
FlowReturn Gst::BaseSink::render_list_vfunc(const Glib::RefPtr<Gst::BufferList>& buffer_list) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->render_list)
  {
    FlowReturn retval(((FlowReturn)((*base->render_list)(gobj(),Glib::unwrap(buffer_list)))));
    return retval;
  }

  using RType = FlowReturn;
  return RType();
}
FlowReturn Gst::BaseSink::prepare_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->prepare)
  {
    FlowReturn retval(((FlowReturn)((*base->prepare)(gobj(),Glib::unwrap(buffer)))));
    return retval;
  }

  using RType = FlowReturn;
  return RType();
}
FlowReturn Gst::BaseSink::prepare_list_vfunc(const Glib::RefPtr<Gst::BufferList>& buffer_list) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->prepare_list)
  {
    FlowReturn retval(((FlowReturn)((*base->prepare_list)(gobj(),Glib::unwrap(buffer_list)))));
    return retval;
  }

  using RType = FlowReturn;
  return RType();
}
bool Gst::BaseSink::propose_allocation_vfunc(const Glib::RefPtr<Gst::Query>& query) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->propose_allocation)
  {
    bool retval((*base->propose_allocation)(gobj(),Glib::unwrap(query)));
    return retval;
  }

  using RType = bool;
  return RType();
}


} // namespace Gst


