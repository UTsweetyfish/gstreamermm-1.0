// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!
#ifndef _GSTREAMERMM_APPSINK_H
#define _GSTREAMERMM_APPSINK_H

#include <gstreamermmconfig.h>

#ifndef GSTREAMERMM_DISABLE_DEPRECATED


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

// Generated by generate_plugin_gmmproc_file. Don't edit this file.


#include <gstreamermm/basesink.h>
#include <gstreamermm/caps.h>
#include <gstreamermm/pad.h>
#include <gstreamermm/sample.h>
#include <gstreamermm/urihandler.h>


// Plug-in C enums used in signals:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
using GstAppSink = struct _GstAppSink;
using GstAppSinkClass = struct _GstAppSinkClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Gst
{ class AppSink_Class; } // namespace Gst
#endif //DOXYGEN_SHOULD_SKIP_THIS

namespace Gst
{

/** A Wrapper for the appsink plugin.
 * Please note that not all plug-ins are available on all systems so care
 * must be taken that they exist before they are used otherwise there will
 * be errors and possibly a crash.
 *
 * @ingroup GstPlugins
 * @deprecated Plugins API is deprecated, and should not be used in a new code.
 */

class AppSink
: public Gst::BaseSink, public Gst::URIHandler
{
  
#ifndef DOXYGEN_SHOULD_SKIP_THIS

public:
  using CppObjectType = AppSink;
  using CppClassType = AppSink_Class;
  using BaseObjectType = GstAppSink;
  using BaseClassType = GstAppSinkClass;

  // noncopyable
  AppSink(const AppSink&) = delete;
  AppSink& operator=(const AppSink&) = delete;

private:  friend class AppSink_Class;
  static CppClassType appsink_class_;

protected:
  explicit AppSink(const Glib::ConstructParams& construct_params);
  explicit AppSink(GstAppSink* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:

  AppSink(AppSink&& src) noexcept;
  AppSink& operator=(AppSink&& src) noexcept;

  ~AppSink() noexcept override;

  /** Get the GType for this class, for use with the underlying GObject type system.
   */
  static GType get_type()      G_GNUC_CONST;

#ifndef DOXYGEN_SHOULD_SKIP_THIS


  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GObject.
  GstAppSink*       gobj()       { return reinterpret_cast<GstAppSink*>(gobject_); }

  ///Provides access to the underlying C GObject.
  const GstAppSink* gobj() const { return reinterpret_cast<GstAppSink*>(gobject_); }

  ///Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.
  GstAppSink* gobj_copy();

private:

  
protected:
  AppSink();
  explicit AppSink(const Glib::ustring& name);

public:
  /** Creates a new appsink plugin with a unique name.
   */
  
  static Glib::RefPtr<AppSink> create();


  /** Creates a new appsink plugin with the given name.
   */
  
  static Glib::RefPtr<AppSink> create(const Glib::ustring& name);


  /** This is a convenience method for the action signal
   * signal_pull_preroll().
   */
  Glib::RefPtr<Gst::Sample> pull_preroll();

  /** This is a convenience method for the action signal
   * signal_pull_sample().
   */
  Glib::RefPtr<Gst::Sample> pull_sample();

  /** This is a convenience method for the action signal
   * signal_try_pull_preroll().
   */
  Glib::RefPtr<Gst::Sample> try_pull_preroll(guint64 arg0);

  /** This is a convenience method for the action signal
   * signal_try_pull_sample().
   */
  Glib::RefPtr<Gst::Sample> try_pull_sample(guint64 arg0);


  /** The allowed caps for the sink pad.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< Glib::RefPtr<Gst::Caps> > property_caps() ;

/** The allowed caps for the sink pad.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gst::Caps> > property_caps() const;

  /** Check if the sink is EOS or not started.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_eos() const;


  /** Emit new-preroll and new-sample signals.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_emit_signals() ;

/** Emit new-preroll and new-sample signals.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_emit_signals() const;

  /** The maximum number of buffers to queue internally (0 = unlimited).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< guint > property_max_buffers() ;

/** The maximum number of buffers to queue internally (0 = unlimited).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< guint > property_max_buffers() const;

  /** Drop old buffers when the buffer queue is filled.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_drop() ;

/** Drop old buffers when the buffer queue is filled.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_drop() const;

  /** Wait for all buffers to be processed after receiving an EOS.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_wait_on_eos() ;

/** Wait for all buffers to be processed after receiving an EOS.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_wait_on_eos() const;


  /**
   * @par Slot Prototype:
   * <tt>void on_my_%eos()</tt>
   *
   * Signal that the end-of-stream has been reached. This signal is emitted from
   * the streaming thread.
   */

  Glib::SignalProxy< void > signal_eos();

  
  /**
   * @par Slot Prototype:
   * <tt>Gst::FlowReturn on_my_%new_preroll()</tt>
   *
   * Signal that a new preroll sample is available.
   * 
   * This signal is emitted from the streaming thread and only when the
   * "emit-signals" property is <tt>true</tt>.
   * 
   * The new preroll sample can be retrieved with the "pull-preroll" action
   * signal or Gst::AppSink::pull_preroll() either from this signal callback
   * or from any other thread.
   * 
   * Note that this signal is only emitted when the "emit-signals" property is
   * set to <tt>true</tt>, which it is not by default for performance reasons.
   */

  Glib::SignalProxy< Gst::FlowReturn > signal_new_preroll();

  
  /**
   * @par Slot Prototype:
   * <tt>Gst::FlowReturn on_my_%new_sample()</tt>
   *
   * Signal that a new sample is available.
   * 
   * This signal is emitted from the streaming thread and only when the
   * "emit-signals" property is <tt>true</tt>.
   * 
   * The new sample can be retrieved with the "pull-sample" action
   * signal or Gst::AppSink::pull_sample() either from this signal callback
   * or from any other thread.
   * 
   * Note that this signal is only emitted when the "emit-signals" property is
   * set to <tt>true</tt>, which it is not by default for performance reasons.
   */

  Glib::SignalProxy< Gst::FlowReturn > signal_new_sample();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, pull_preroll().
   *
   * @par Slot Prototype:
   * <tt>Glib::RefPtr<Gst::Sample> on_my_%pull_preroll()</tt>
   *
   * Get the last preroll sample in @a appsink. This was the sample that caused the
   * appsink to preroll in the PAUSED state. This sample can be pulled many times
   * and remains available to the application even after EOS.
   * 
   * This function is typically used when dealing with a pipeline in the PAUSED
   * state. Calling this function after doing a seek will give the sample right
   * after the seek position.
   * 
   * Note that the preroll sample will also be returned as the first sample
   * when calling Gst::AppSink::pull_sample() or the "pull-sample" action signal.
   * 
   * If an EOS event was received before any buffers, this function returns
   * <tt>nullptr</tt>. Use Gst::AppSink::is_eos() to check for the EOS condition.
   * 
   * This function blocks until a preroll sample or EOS is received or the appsink
   * element is set to the READY/<tt>nullptr</tt> state.
   * 
   * @return A Gst::Sample or <tt>nullptr</tt> when the appsink is stopped or EOS.
   */

  Glib::SignalProxy< Glib::RefPtr<Gst::Sample> > signal_pull_preroll();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, pull_sample().
   *
   * @par Slot Prototype:
   * <tt>Glib::RefPtr<Gst::Sample> on_my_%pull_sample()</tt>
   *
   * This function blocks until a sample or EOS becomes available or the appsink
   * element is set to the READY/<tt>nullptr</tt> state.
   * 
   * This function will only return samples when the appsink is in the PLAYING
   * state. All rendered samples will be put in a queue so that the application
   * can pull samples at its own rate.
   * 
   * Note that when the application does not pull samples fast enough, the
   * queued samples could consume a lot of memory, especially when dealing with
   * raw video frames. It's possible to control the behaviour of the queue with
   * the "drop" and "max-buffers" properties.
   * 
   * If an EOS event was received before any buffers, this function returns
   * <tt>nullptr</tt>. Use Gst::AppSink::is_eos() to check for the EOS condition.
   * 
   * @return A Gst::Sample or <tt>nullptr</tt> when the appsink is stopped or EOS.
   */

  Glib::SignalProxy< Glib::RefPtr<Gst::Sample> > signal_pull_sample();


  //gtkmmproc error: try-pull-preroll :  signal defs lookup failed


  //gtkmmproc error: try-pull-sample :  signal defs lookup failed


public:

public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


};

} // namespace Gst


namespace Glib
{
  /** A Glib::wrap() method for this object.
   *
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gst::AppSink
   */
  Glib::RefPtr<Gst::AppSink> wrap(GstAppSink* object, bool take_copy = false);
}


#endif // GSTREAMERMM_DISABLE_DEPRECATED


#endif /* _GSTREAMERMM_APPSINK_H */

