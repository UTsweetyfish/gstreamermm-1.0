// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gstreamermm/audioinfo.h>
#include <gstreamermm/private/audioinfo_p.h>


/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2016 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gstreamermm/caps.h>
#include <gstreamermm/handle_error.h>

namespace Gst
{

AudioInfo::AudioInfo(const Glib::RefPtr<const Gst::Caps>& caps)
: AudioInfo()
{
  if (!from_caps(caps))
  {
    gstreamermm_handle_error(
      "Gst::AudioInfo::AudioInfo(const Glib::RefPtr<const Gst::Caps>&): "
      "Failed to construct Gst::AudioInfo from caps: " + caps->to_string());

  }
}

}

namespace
{
} // anonymous namespace

// static
GType Glib::Value<Gst::AudioFlags>::value_type()
{
  return gst_audio_flags_get_type();
}

// static
GType Glib::Value<Gst::AudioLayout>::value_type()
{
  return gst_audio_layout_get_type();
}


namespace Glib
{

Gst::AudioInfo wrap(GstAudioInfo* object, bool take_copy)
{
  return Gst::AudioInfo(object, take_copy);
}

} // namespace Glib


namespace Gst
{


// static
GType AudioInfo::get_type()
{
  return gst_audio_info_get_type();
}

AudioInfo::AudioInfo()
:
  gobject_ (gst_audio_info_new())
{}

AudioInfo::AudioInfo(const AudioInfo& other)
:
  gobject_ ((other.gobject_) ? gst_audio_info_copy(other.gobject_) : nullptr)
{}

AudioInfo::AudioInfo(AudioInfo&& other) noexcept
:
  gobject_(other.gobject_)
{
  other.gobject_ = nullptr;
}

AudioInfo& AudioInfo::operator=(AudioInfo&& other) noexcept
{
  AudioInfo temp (other);
  swap(temp);
  return *this;
}

AudioInfo::AudioInfo(GstAudioInfo* gobject, bool make_a_copy)
:
  // For BoxedType wrappers, make_a_copy is true by default.  The static
  // BoxedType wrappers must always take a copy, thus make_a_copy = true
  // ensures identical behaviour if the default argument is used.
  gobject_ ((make_a_copy && gobject) ? gst_audio_info_copy(gobject) : gobject)
{}

AudioInfo& AudioInfo::operator=(const AudioInfo& other)
{
  AudioInfo temp (other);
  swap(temp);
  return *this;
}

AudioInfo::~AudioInfo() noexcept
{
  if(gobject_)
    gst_audio_info_free(gobject_);
}

void AudioInfo::swap(AudioInfo& other) noexcept
{
  std::swap(gobject_, other.gobject_);
}

GstAudioInfo* AudioInfo::gobj_copy() const
{
  return gst_audio_info_copy(gobject_);
}


bool AudioInfo::is_equal(const Gst::AudioInfo& other) const
{
  return gst_audio_info_is_equal(const_cast<GstAudioInfo*>(gobj()), other.gobj());
}

void AudioInfo::init()
{
  gst_audio_info_init(gobj());
}

bool AudioInfo::from_caps(const Glib::RefPtr<const Gst::Caps>& caps)
{
  return gst_audio_info_from_caps(gobj(), Glib::unwrap(caps));
}

Glib::RefPtr<Gst::Caps> AudioInfo::to_caps() const
{
  return Glib::wrap(gst_audio_info_to_caps(const_cast<GstAudioInfo*>(gobj())));
}

bool AudioInfo::convert(Gst::Format fmt, gint64 src_val, Gst::Format dest_fmt, gint64& dest_val) const
{
  return gst_audio_info_convert(const_cast<GstAudioInfo*>(gobj()), ((GstFormat)(fmt)), src_val, ((GstFormat)(dest_fmt)), &(dest_val));
}

void AudioInfo::set_format(Gst::AudioFormat format, int rate, int channels, const Gst::AudioChannelPosition * position)
{
  gst_audio_info_set_format(gobj(), ((GstAudioFormat)(format)), rate, channels, reinterpret_cast<const GstAudioChannelPosition*>(position));
}

Gst::AudioFlags AudioInfo::get_flags() const
{
  return ((Gst::AudioFlags)(gobj()->flags));
}

void AudioInfo::set_flags(const Gst::AudioFlags& value)
{
  gobj()->flags = ((GstAudioFlags)(value));
}

Gst::AudioLayout AudioInfo::get_layout() const
{
  return ((Gst::AudioLayout)(gobj()->layout));
}

void AudioInfo::set_layout(const Gst::AudioLayout& value)
{
  gobj()->layout = ((GstAudioLayout)(value));
}

int AudioInfo::get_rate() const
{
  return gobj()->rate;
}

void AudioInfo::set_rate(const int& value)
{
  gobj()->rate = value;
}

int AudioInfo::get_channels() const
{
  return gobj()->channels;
}

void AudioInfo::set_channels(const int& value)
{
  gobj()->channels = value;
}

int AudioInfo::get_bpf() const
{
  return gobj()->bpf;
}

void AudioInfo::set_bpf(const int& value)
{
  gobj()->bpf = value;
}

const Gst::AudioFormatInfo AudioInfo::get_finfo() const
{
  return Gst::AudioFormatInfo(gobj()->finfo);
}


} // namespace Gst


