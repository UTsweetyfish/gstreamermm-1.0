// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!
#ifndef _GSTREAMERMM_BASESINK_H
#define _GSTREAMERMM_BASESINK_H


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2016 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/base/gstbasesink.h>
#include <gstreamermm/element.h>
#include <gstreamermm/buffer.h>
#include <gstreamermm/pad.h>
#include <gstreamermm/caps.h>
#include <gstreamermm/sample.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
using GstBaseSink = struct _GstBaseSink;
using GstBaseSinkClass = struct _GstBaseSinkClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Gst
{ class BaseSink_Class; } // namespace Gst
#endif //DOXYGEN_SHOULD_SKIP_THIS

namespace Gst
{

class BufferList;

/** The base class for sink elements.
 * Gst::BaseSink is the base class for sink elements in GStreamer, such as
 * xvimagesink or filesink. It is a layer on top of Gst::Element that provides
 * a simplified interface to plugin writers. Gst::BaseSink handles many details
 * for you, for example: preroll, clock synchronization, state changes,
 * activation in push or pull mode, and queries.
 *
 * In most cases, when writing sink elements, there is no need to implement
 * class methods from Gst::Element or to set functions on pads, because the
 * Gst::BaseSink infrastructure should be sufficient.
 *
 * TODO: correct paragraph below for C++ and include example from C API:
 *
 * Gst::BaseSink provides support for exactly one sink pad, which should be
 * named "sink". A sink implementation (subclass of Gst::BaseSink) should
 * install a pad template in its base_init function, like so:
 *
 * Gst::BaseSink will handle the prerolling correctly. This means that it will
 * return Gst::STATE_CHANGE_ASYNC from a state change to PAUSED until the first
 * buffer arrives in this element. The base class will call the
 * Gst::BaseSink::preroll_vfunc() vmethod with this preroll buffer and will
 * then commit the state change to the next asynchronously pending state.
 *
 * When the element is set to PLAYING, Gst::BaseSink will synchronise on the
 * clock using the times returned from get_times_vfunc(). If this function
 * returns Gst::CLOCK_TIME_NONE for the start time, no synchronisation will be
 * done.  Synchronisation can be disabled entirely by setting the object "sync"
 * property to FALSE.
 *
 * After synchronisation the virtual method Gst::BaseSink::render_vfunc() will
 * be called. Subclasses should minimally implement this method.
 *
 * Since GStreamer 0.10.3 subclasses that synchronise on the clock in the
 * render_vfunc() vmethod are supported as well. These classes typically
 * receive a buffer in the render method and can then potentially block on the
 * clock while rendering. A typical example is an audiosink. Since GStreamer
 * 0.10.11 these subclasses can use wait_preroll() to perform the blocking
 * wait.
 *
 * Upon receiving the EOS event in the PLAYING state, Gst::BaseSink will wait
 * for the clock to reach the time indicated by the stop time of the last
 * get_times_vfunc() call before posting an EOS message. When the element
 * receives EOS in PAUSED, preroll completes, the event is queued and an EOS
 * message is posted when going to PLAYING.
 *
 * Gst::BaseSink will internally use the Gst::EVENT_NEWSEGMENT events to
 * schedule synchronisation and clipping of buffers. Buffers that fall
 * completely outside of the current segment are dropped. Buffers that fall
 * partially in the segment are rendered (and prerolled). Subclasses should do
 * any subbuffer clipping themselves when needed.
 *
 * Gst::BaseSink will by default report the current playback position in
 * Gst::FORMAT_TIME based on the current clock time and segment information. If
 * no clock has been set on the element, the query will be forwarded upstream.
 *
 * The set_caps_vfunc() function will be called when the subclass should
 * configure itself to process a specific media type.
 *
 * The start_vfunc() and stop_vfunc() virtual methods will be called when
 * resources should be allocated. Any preroll_vfunc(), render_vfunc() and
 * set_caps_vfunc() function will be called between the start_vfunc() and
 * stop_vfunc() calls.
 *
 * The event_vfunc() virtual method will be called when an event is received by
 * Gst::BaseSink. Normally this method should only be overriden by very
 * specific elements (such as file sinks) which need to handle the newsegment
 * event specially.
 * The unlock_vfunc() method is called when the elements should unblock any
 * blocking operations they perform in the render_vfunc() method. This is
 * mostly useful when the render_vfunc() method performs a blocking write on a
 * file descriptor, for example.
 *
 * The max-lateness property affects how the sink deals with buffers that
 * arrive too late in the sink. A buffer arrives too late in the sink when the
 * presentation time (as a combination of the last segment, buffer timestamp
 * and element base_time) plus the duration is before the current time of the
 * clock. If the frame is later than max-lateness, the sink will drop the
 * buffer without calling the render method. This feature is disabled if sync
 * is disabled, the get_times_vfunc() method does not return a valid start time
 * or max-lateness is set to -1 (the default). Subclasses can use
 * set_max_lateness() to configure the max-lateness value.
 *
 * The qos property will enable the quality-of-service features of the basesink
 * which gather statistics about the real-time performance of the clock
 * synchronisation. For each buffer received in the sink, statistics are
 * gathered and a QOS event is sent upstream with these numbers. This
 * information can then be used by upstream elements to reduce their processing
 * rate, for example.
 *
 * The async property can be used to instruct the sink
 * to never perform an ASYNC state change. This feature is mostly usable when
 * dealing with non-synchronized streams or sparse streams.
 *
 * Last reviewed on 2016-04-29 (1.8.0)
 *
 * @ingroup GstBaseClasses
 */

class BaseSink
: public Element
{
  
#ifndef DOXYGEN_SHOULD_SKIP_THIS

public:
  using CppObjectType = BaseSink;
  using CppClassType = BaseSink_Class;
  using BaseObjectType = GstBaseSink;
  using BaseClassType = GstBaseSinkClass;

  // noncopyable
  BaseSink(const BaseSink&) = delete;
  BaseSink& operator=(const BaseSink&) = delete;

private:  friend class BaseSink_Class;
  static CppClassType basesink_class_;

protected:
  explicit BaseSink(const Glib::ConstructParams& construct_params);
  explicit BaseSink(GstBaseSink* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:

  BaseSink(BaseSink&& src) noexcept;
  BaseSink& operator=(BaseSink&& src) noexcept;

  ~BaseSink() noexcept override;

  /** Get the GType for this class, for use with the underlying GObject type system.
   */
  static GType get_type()      G_GNUC_CONST;

#ifndef DOXYGEN_SHOULD_SKIP_THIS


  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GObject.
  GstBaseSink*       gobj()       { return reinterpret_cast<GstBaseSink*>(gobject_); }

  ///Provides access to the underlying C GObject.
  const GstBaseSink* gobj() const { return reinterpret_cast<GstBaseSink*>(gobject_); }

  ///Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.
  GstBaseSink* gobj_copy();

private:


public:
  
  /** Query the sink for the latency parameters. The latency will be queried from
   * the upstream elements. @a live will be <tt>true</tt> if @a sink is configured to
   * synchronize against the clock. @a upstream_live will be <tt>true</tt> if an upstream
   * element is live.
   * 
   * If both @a live and @a upstream_live are <tt>true</tt>, the sink will want to compensate
   * for the latency introduced by the upstream elements by setting the
   *  @a min_latency to a strictly positive value.
   * 
   * This function is mostly used by subclasses.
   * 
   * @param live If the sink is live.
   * @param upstream_live If an upstream element is live.
   * @param min_latency The min latency of the upstream elements.
   * @param max_latency The max latency of the upstream elements.
   * @return <tt>true</tt> if the query succeeded.
   */
  bool query_latency(bool& live, bool& upstream_live, Gst::ClockTime& min_latency, Gst::ClockTime& max_latency) const;
  
  /** Get the currently configured latency.
   * 
   * @return The configured latency.
   */
  Gst::ClockTime get_latency() const;
  
  /** If the @a sink spawns its own thread for pulling buffers from upstream it
   * should call this method after it has pulled a buffer. If the element needed
   * to preroll, this function will perform the preroll and will then block
   * until the element state is changed.
   * 
   * This function should be called with the PREROLL_LOCK held.
   * 
   * @param obj The mini object that caused the preroll.
   * @return Gst::FLOW_OK if the preroll completed and processing can
   * continue. Any other return value should be returned from the render vmethod.
   */
  Gst::FlowReturn do_preroll(const Glib::RefPtr<Gst::MiniObject>& obj);
  
  /** If the Gst::BaseSinkClass.render() method performs its own synchronisation
   * against the clock it must unblock when going from PLAYING to the PAUSED state
   * and call this method before continuing to render the remaining data.
   * 
   * This function will block until a state change to PLAYING happens (in which
   * case this function returns Gst::FLOW_OK) or the processing must be stopped due
   * to a state change to READY or a FLUSH event (in which case this function
   * returns Gst::FLOW_FLUSHING).
   * 
   * This function should only be called with the PREROLL_LOCK held, like in the
   * render function.
   * 
   * @return Gst::FLOW_OK if the preroll completed and processing can
   * continue. Any other return value should be returned from the render vmethod.
   */
  Gst::FlowReturn wait_preroll();
  
  /** This function will block until @a time is reached. It is usually called by
   * subclasses that use their own internal synchronisation.
   * 
   * If @a time is not valid, no synchronisation is done and Gst::CLOCK_BADTIME is
   * returned. Likewise, if synchronisation is disabled in the element or there
   * is no clock, no synchronisation is done and Gst::CLOCK_BADTIME is returned.
   * 
   * This function should only be called with the PREROLL_LOCK held, like when
   * receiving an EOS event in the Gst::BaseSinkClass.event() vmethod or when
   * receiving a buffer in
   * the Gst::BaseSinkClass.render() vmethod.
   * 
   * The @a time argument should be the running_time of when this method should
   * return and is not adjusted with any latency or offset configured in the
   * sink.
   * 
   * @param time The running_time to be reached.
   * @param jitter The jitter to be filled with time diff, or <tt>nullptr</tt>.
   * @return Gst::ClockReturn.
   */
  Gst::ClockReturn wait_clock(Gst::ClockTime time, Gst::ClockTimeDiff& jitter);

  /// A wait_clock() convenience overload.
  Gst::ClockReturn wait_clock(Gst::ClockTime time);
  
  /** This function will wait for preroll to complete and will then block until @a time
   * is reached. It is usually called by subclasses that use their own internal
   * synchronisation but want to let some synchronization (like EOS) be handled
   * by the base class.
   * 
   * This function should only be called with the PREROLL_LOCK held (like when
   * receiving an EOS event in the signal_event() vmethod or when handling buffers in
   * signal_render()).
   * 
   * The @a time argument should be the running_time of when the timeout should happen
   * and will be adjusted with any latency and offset configured in the sink.
   * 
   * @param time The running_time to be reached.
   * @param jitter The jitter to be filled with time diff, or <tt>nullptr</tt>.
   * @return Gst::FlowReturn.
   */
  Gst::FlowReturn wait(Gst::ClockTime time, Gst::ClockTimeDiff& jitter);

  /// A wait() convenience overload.
  Gst::FlowReturn wait(Gst::ClockTime time);

  
  /** Configures @a sink to synchronize on the clock or not. When
   *  @a sync is <tt>false</tt>, incoming samples will be played as fast as
   * possible. If @a sync is <tt>true</tt>, the timestamps of the incoming
   * buffers will be used to schedule the exact render time of its
   * contents.
   * 
   * @param sync The new sync value.
   */
  void set_sync(bool sync);
  
  /** Checks if @a sink is currently configured to synchronize against the
   * clock.
   * 
   * @return <tt>true</tt> if the sink is configured to synchronize against the clock.
   */
  bool get_sync() const;

  
  /** Sets the new max lateness value to @a max_lateness. This value is
   * used to decide if a buffer should be dropped or not based on the
   * buffer timestamp and the current clock time. A value of -1 means
   * an unlimited time.
   * 
   * @param max_lateness The new max lateness value.
   */
  void set_max_lateness(gint64 max_lateness);
  
  /** Gets the max lateness value. See gst_base_sink_set_max_lateness for
   * more details.
   * 
   * @return The maximum time in nanoseconds that a buffer can be late
   * before it is dropped and not rendered. A value of -1 means an
   * unlimited time.
   */
  gint64 get_max_lateness() const;

  
  /** Configures @a sink to send Quality-of-Service events upstream.
   * 
   * @param enabled The new qos value.
   */
  void set_qos_enabled(bool enabled);
  
  /** Checks if @a sink is currently configured to send Quality-of-Service events
   * upstream.
   * 
   * @return <tt>true</tt> if the sink is configured to perform Quality-of-Service.
   */
  bool is_qos_enabled() const;

  
  /** Configures @a sink to perform all state changes asynchronously. When async is
   * disabled, the sink will immediately go to PAUSED instead of waiting for a
   * preroll buffer. This feature is useful if the sink does not synchronize
   * against the clock or when it is dealing with sparse streams.
   * 
   * @param enabled The new async value.
   */
  void set_async_enabled(bool enabled);
  
  /** Checks if @a sink is currently configured to perform asynchronous state
   * changes to PAUSED.
   * 
   * @return <tt>true</tt> if the sink is configured to perform asynchronous state
   * changes.
   */
  bool is_async_enabled() const;

  
  /** Adjust the synchronisation of @a sink with @a offset. A negative value will
   * render buffers earlier than their timestamp. A positive value will delay
   * rendering. This function can be used to fix playback of badly timestamped
   * buffers.
   * 
   * @param offset The new offset.
   */
  void set_ts_offset(Gst::ClockTimeDiff offset);
  
  /** Get the synchronisation offset of @a sink.
   * 
   * @return The synchronisation offset.
   */
  Gst::ClockTimeDiff get_ts_offset() const;

  
  /** Set the render delay in @a sink to @a delay. The render delay is the time
   * between actual rendering of a buffer and its synchronisation time. Some
   * devices might delay media rendering which can be compensated for with this
   * function.
   * 
   * After calling this function, this sink will report additional latency and
   * other sinks will adjust their latency to delay the rendering of their media.
   * 
   * This function is usually called by subclasses.
   * 
   * @param delay The new delay.
   */
  void set_render_delay(Gst::ClockTime delay);
  
  /** Get the render delay of @a sink. see set_render_delay() for more
   * information about the render delay.
   * 
   * @return The render delay of @a sink.
   */
  Gst::ClockTime get_render_delay() const;

  
  /** Set the number of bytes that the sink will pull when it is operating in pull
   * mode.
   * 
   * @param blocksize The blocksize in bytes.
   */
  void set_blocksize(guint blocksize);
  
  /** Get the number of bytes that the sink will pull when it is operating in pull
   * mode.
   * 
   * @return The number of bytes @a sink will pull in pull mode.
   */
  guint get_blocksize() const;

  
  /** Get the time that will be inserted between frames to control the 
   * maximum buffers per second.
   * 
   * @return The number of nanoseconds @a sink will put between frames.
   */
  guint64 get_throttle_time() const;
  
  /** Set the time that will be inserted between rendered buffers. This
   * can be used to control the maximum buffers per second that the sink
   * will render.
   * 
   * @param throttle The throttle time in nanoseconds.
   */
  void set_throttle_time(guint64 throttle);

  
  /** Get the last sample that arrived in the sink and was used for preroll or for
   * rendering. This property can be used to generate thumbnails.
   * 
   * The Gst::Caps on the sample can be used to determine the type of the buffer.
   * 
   * Free-function: gst_sample_unref
   * 
   * @return A Gst::Sample. gst_sample_unref() after
   * usage.  This function returns <tt>nullptr</tt> when no buffer has arrived in the
   * sink yet or when the sink is not in PAUSED or PLAYING.
   */
  Glib::RefPtr<Gst::Sample> get_last_sample() const;

  
  /** Set the maximum amount of bits per second that the sink will render.
   * 
   * @param max_bitrate The max_bitrate in bits per second.
   */
  void set_max_bitrate(guint64 max_bitrate);
  
  /** Get the maximum amount of bits per second that the sink will render.
   * 
   * @return The maximum number of bits per second @a sink will render.
   */
  guint64 get_max_bitrate() const;

  
  /** Configures @a sink to store the last received sample in the last-sample
   * property.
   * 
   * @param enabled The new enable-last-sample value.
   */
  void set_last_sample_enabled(bool enabled);
  
  /** Checks if @a sink is currently configured to store the last received sample in
   * the last-sample property.
   * 
   * @return <tt>true</tt> if the sink is configured to store the last received sample.
   */
  bool is_last_sample_enabled() const;

  /** Gets the sink Gst::Pad object of the element.
   */
  Glib::RefPtr<Gst::Pad> get_sink_pad();
  Glib::RefPtr<const Gst::Pad> get_sink_pad() const;

  // TODO: wrap preroll?

  /** Go asynchronously to PAUSED.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_async() ;

/** Go asynchronously to PAUSED.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_async() const;

  /** Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< gint64 > property_max_lateness() ;

/** Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< gint64 > property_max_lateness() const;

  /** Generate Quality-of-Service events upstream.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_qos() ;

/** Generate Quality-of-Service events upstream.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_qos() const;

  /** Sync on the clock.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_sync() ;

/** Sync on the clock.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_sync() const;

  /** Timestamp offset in nanoseconds.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< gint64 > property_ts_offset() ;

/** Timestamp offset in nanoseconds.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< gint64 > property_ts_offset() const;

  /** Additional render delay of the sink in nanoseconds.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< guint64 > property_render_delay() ;

/** Additional render delay of the sink in nanoseconds.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< guint64 > property_render_delay() const;

  /** The time to keep between rendered buffers (0 = disabled).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< guint64 > property_throttle_time() ;

/** The time to keep between rendered buffers (0 = disabled).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< guint64 > property_throttle_time() const;

  /** Size in bytes to pull per buffer (0 = default).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< guint > property_blocksize() ;

/** Size in bytes to pull per buffer (0 = default).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< guint > property_blocksize() const;

  /** The last sample received in the sink.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gst::Sample> > property_last_sample() const;


  /** Enable the last-sample property.
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< bool > property_enable_last_sample() ;

/** Enable the last-sample property.
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_enable_last_sample() const;

  /** The maximum bits per second to render (0 = disabled).
   *
   * @return A PropertyProxy that allows you to get or set the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy< guint64 > property_max_bitrate() ;

/** The maximum bits per second to render (0 = disabled).
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< guint64 > property_max_bitrate() const;


  /** Called to get sink pad caps from the subclass.
   */
    virtual Glib::RefPtr<Gst::Caps> get_caps_vfunc(const Glib::RefPtr<Gst::Caps>& caps) const;


  /** Notify subclass of changed caps.
   */
    virtual bool set_caps_vfunc(const Glib::RefPtr<Gst::Caps>& caps);


  /** Called to get the start and end times for synchronising the passed buffer
   * to the clock.
   */
    virtual void get_times_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer, Gst::ClockTime& start, Gst::ClockTime& end) const;


  /** Start processing. Ideal for opening resources in the subclass.
   */
    virtual bool start_vfunc();


  /** Stop processing. Subclasses should use this to close resources.
   */
    virtual bool stop_vfunc();


  /** Unlock any pending access to the resource. Subclasses should unblock any
   * blocked function ASAP.
   */
    virtual bool unlock_vfunc();


  /** Override this to handle events arriving on the sink pad.
   */
    virtual bool event_vfunc(const Glib::RefPtr<Gst::Event>& event);


  /** Override this to implement custom logic to wait for the event time (for events
   * like EOS and GAP). Subclasses should always first chain up to the default
   * implementation.
   */
    virtual FlowReturn wait_event_vfunc(const Glib::RefPtr<Gst::Event>& event);


  /** Called to present the preroll buffer if desired.
   */
    virtual FlowReturn preroll_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer);


  /** Called when a buffer should be presented or output, at the correct moment
   * if the Gst::BaseSink has been set to sync to the clock.
   */
    virtual FlowReturn render_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer);


  /** Subclasses should override this when they need to perform special
   * processing when changing to the PLAYING state asynchronously. Called with
   * the OBJECT_LOCK held.
   */

  /** Subclasses should override this when they can provide an alternate method
   * of spawning a thread to drive the pipeline in pull mode. Should start or
   * stop the pulling thread, depending on the value of the "active" argument.
   * Called after actually activating the sink pad in pull mode. The default
   * implementation starts a task on the sink pad. 
   */
    virtual bool activate_pull_vfunc(bool active);


  /** Only useful in pull mode, this vmethod will be called in response to
   * Gst::Pad::fixate_caps() being called on the sink pad. Implement if you
   * have ideas about what should be the default values for the caps you
   * support.
   */
    virtual Glib::RefPtr<Gst::Caps> fixate_vfunc(const Glib::RefPtr<Gst::Caps>& caps);


  /** Clear the previous unlock request. Subclasses should clear any state they
   * set during unlock_vfunc(), such as clearing command queues.
   */
    virtual bool unlock_stop_vfunc();


  /// Render a BufferList.
  /** Same as render but used with buffer lists instead of buffers.
   */
    virtual FlowReturn render_list_vfunc(const Glib::RefPtr<Gst::BufferList>& buffer_list);


  /** Called to prepare the buffer for render and preroll.
   * This function is called before synchronisation is performed.
   */
    virtual FlowReturn prepare_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer);


  /** Called to prepare the buffer list for render_list.
   * This function is called before synchronisation is performed.
   */
    virtual FlowReturn prepare_list_vfunc(const Glib::RefPtr<Gst::BufferList>& buffer_list);


  // Cannot use query_vfunc because the name has been used in the Gst::Element class.
  // We have to provide custom implementation, because query vfunc expects writable
  // query object.
  /** Perform a GstQuery on the element.
   */
  virtual bool base_sink_query_vfunc(const Glib::RefPtr<Gst::Query>& query);

  /** Configure the allocation query.
   */
 

    virtual bool propose_allocation_vfunc(const Glib::RefPtr<Gst::Query>& query);


protected:

  
public:

public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


};

} // namespace Gst


namespace Glib
{
  /** A Glib::wrap() method for this object.
   *
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gst::BaseSink
   */
  Glib::RefPtr<Gst::BaseSink> wrap(GstBaseSink* object, bool take_copy = false);
}


#endif /* _GSTREAMERMM_BASESINK_H */

