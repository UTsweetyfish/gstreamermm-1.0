// Generated by gmmproc 2.50.1 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gstreamermm/basetransform.h>
#include <gstreamermm/private/basetransform_p.h>


/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2016 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gstreamermm/pad.h>
#include <gstreamermm/caps.h>
#include <gstreamermm/buffer.h>


#define IGNORE_RESULT(x) { auto release_value = x; (void)release_value; }

namespace Gst
{

const Glib::ustring BaseTransform::SINK_NAME = GST_BASE_TRANSFORM_SINK_NAME;
const Glib::ustring BaseTransform::SRC_NAME = GST_BASE_TRANSFORM_SRC_NAME;

GstFlowReturn BaseTransform_Class::prepare_output_buffer_vfunc_callback(GstBaseTransform* self, GstBuffer* input, GstBuffer** buffer)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        Glib::RefPtr<Gst::Buffer> cpp_buffer;
        // Call the virtual member method, which derived classes might override.
        const GstFlowReturn result =
          static_cast<GstFlowReturn>(obj->prepare_output_buffer_vfunc(
          Glib::wrap(input, true), cpp_buffer));
          *buffer = cpp_buffer ? cpp_buffer->gobj_copy() : 0;
        return result;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->prepare_output_buffer)
    return (*base->prepare_output_buffer)(self, input, buffer);


  typedef GstFlowReturn RType;
  return RType();
}
FlowReturn Gst::BaseTransform::prepare_output_buffer_vfunc(const Glib::RefPtr<Gst::Buffer>& input, Glib::RefPtr<Gst::Buffer>& buffer)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->prepare_output_buffer)
  {
    GstBuffer* gst_buffer;
    const Gst::FlowReturn result =
      static_cast<Gst::FlowReturn>((*base->prepare_output_buffer)(gobj(),
      Glib::unwrap(input), &gst_buffer));
    buffer = Glib::wrap(gst_buffer, false); // Don't take copy because callback returns a newly created copy.
    return result;
  }

  typedef FlowReturn RType;
  return RType();
}

Glib::RefPtr<Allocator> BaseTransform::get_allocator(AllocationParams& params)
{
  GstAllocator* alloc;
  gst_base_transform_get_allocator(gobj(), &alloc, params.gobj());
  return Glib::wrap(alloc, false);
}

GstFlowReturn BaseTransform_Class::transform_vfunc_callback(GstBaseTransform* self, GstBuffer* inbuf, GstBuffer* outbuf)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        Glib::RefPtr<Gst::Buffer> w_inbuf = Glib::wrap(inbuf, false),
            w_outbuf = Glib::wrap(outbuf, false);
        // Call the virtual member method, which derived classes might override.
        GstFlowReturn ret = ((GstFlowReturn)(obj->transform_vfunc(w_inbuf, w_outbuf)));
        w_inbuf->reference(); w_outbuf->reference();
        return ret;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->transform)
  {
    GstFlowReturn retval = (*base->transform)(self, inbuf, outbuf);
    return retval;
  }

  typedef GstFlowReturn RType;
  return RType();
}

FlowReturn Gst::BaseTransform::transform_vfunc(const Glib::RefPtr<Gst::Buffer>& inbuf, const Glib::RefPtr<Gst::Buffer>& outbuf) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->transform)
  {
    FlowReturn retval(((FlowReturn)((*base->transform)(gobj(),Glib::unwrap(inbuf),Glib::unwrap(outbuf)))));
    return retval;
  }

  typedef FlowReturn RType;
  return RType();
}

GstFlowReturn BaseTransform_Class::generate_output_vfunc_callback(GstBaseTransform* self, GstBuffer** outbuf)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        Glib::RefPtr<Gst::Buffer> cpp_buffer;
        // Call the virtual member method, which derived classes might override.
        const GstFlowReturn result =
          static_cast<GstFlowReturn>(obj->generate_output_vfunc(
          cpp_buffer));
          *outbuf = cpp_buffer ? cpp_buffer->gobj_copy() : 0;
        return result;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->generate_output)
    return (*base->generate_output)(self, outbuf);


  typedef GstFlowReturn RType;
  return RType();
}

FlowReturn Gst::BaseTransform::generate_output_vfunc(Glib::RefPtr<Gst::Buffer>& outbuf)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->generate_output)
  {
    GstBuffer* gst_buffer = nullptr;
    const Gst::FlowReturn result =
      static_cast<Gst::FlowReturn>((*base->generate_output)(gobj(), &gst_buffer));
    outbuf = Glib::wrap(gst_buffer, false); // Don't take copy because callback returns a newly created copy.
    return result;
  }

  typedef FlowReturn RType;
  return RType();
}

gboolean BaseTransform_Class::query_vfunc_callback(GstBaseTransform* self, GstPadDirection direction, GstQuery* query)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        auto query_cpp = Glib::wrap(query, false);
        int ret = static_cast<int>(obj->base_transform_query_vfunc(static_cast<Gst::PadDirection>(direction), query_cpp));
        IGNORE_RESULT(query_cpp.release());
        return ret;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->query)
  {
    gboolean retval = (*base->query)(self, direction, query);
    return retval;
  }

  typedef gboolean RType;
  return RType();
}


bool Gst::BaseTransform::base_transform_query_vfunc(Gst::PadDirection direction, const Glib::RefPtr<Gst::Query>& query)
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->query)
  {
    bool retval((*base->query)(gobj(), static_cast<GstPadDirection>(direction), Glib::unwrap(query)));
    return retval;
  }

  typedef bool RType;
  return RType();
}

bool BaseTransform::propose_allocation_vfunc(const Glib::RefPtr<Gst::Query>& decide_query, const Glib::RefPtr<Gst::Query>& query)
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->propose_allocation)
  {
    bool retval((*base->propose_allocation)(gobj(),Glib::unwrap(decide_query),Glib::unwrap(query)));
    return retval;
  }

  typedef bool RType;
  return RType();
}

gboolean BaseTransform_Class::propose_allocation_vfunc_callback(GstBaseTransform* self, GstQuery* decide_query, GstQuery* query)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        auto query_cpp = Glib::wrap(query, false);
        auto decide_query_cpp = Glib::wrap(decide_query, false);
        auto ret = static_cast<int>(obj->propose_allocation_vfunc(decide_query_cpp, query_cpp));
        IGNORE_RESULT(query_cpp.release());
        IGNORE_RESULT(decide_query_cpp.release());
        return ret;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->propose_allocation)
    return (*base->propose_allocation)(self, decide_query, query);

  typedef gboolean RType;
  return RType();
}

bool Gst::BaseTransform::decide_allocation_vfunc(const Glib::RefPtr<Gst::Query>& query)
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->decide_allocation)
  {
    bool retval((*base->decide_allocation)(gobj(),Glib::unwrap(query)));
    return retval;
  }

  typedef bool RType;
  return RType();
}

gboolean BaseTransform_Class::decide_allocation_vfunc_callback(GstBaseTransform* self, GstQuery* query)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
          auto query_cpp = Glib::wrap(query, false);
          auto ret = static_cast<int>(obj->decide_allocation_vfunc(query_cpp));
          IGNORE_RESULT(query_cpp.release());
          return ret;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->decide_allocation)
    return (*base->decide_allocation)(self, query);

  typedef gboolean RType;
  return RType();
}


} //namespace Gst

namespace
{
} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Gst::BaseTransform> wrap(GstBaseTransform* object, bool take_copy)
{
  return Glib::RefPtr<Gst::BaseTransform>( dynamic_cast<Gst::BaseTransform*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gst
{


/* The *_Class implementation: */

const Glib::Class& BaseTransform_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &BaseTransform_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gst_base_transform_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void BaseTransform_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

  klass->transform_caps = &transform_caps_vfunc_callback;
  klass->fixate_caps = &fixate_caps_vfunc_callback;
  klass->get_unit_size = &get_unit_size_vfunc_callback;
  klass->set_caps = &set_caps_vfunc_callback;
  klass->transform_ip = &transform_ip_vfunc_callback;
  klass->src_event = &src_event_vfunc_callback;
  klass->sink_event = &sink_event_vfunc_callback;
  klass->before_transform = &before_transform_vfunc_callback;
  klass->accept_caps = &accept_caps_vfunc_callback;
  klass->start = &start_vfunc_callback;
  klass->stop = &stop_vfunc_callback;
  klass->filter_meta = &filter_meta_vfunc_callback;
  klass->submit_input_buffer = &submit_input_buffer_vfunc_callback;
  klass->copy_metadata = &copy_metadata_vfunc_callback;
  klass->prepare_output_buffer = &prepare_output_buffer_vfunc_callback;
  klass->transform = &transform_vfunc_callback;
  klass->generate_output = &generate_output_vfunc_callback;
  klass->query = &query_vfunc_callback;
  klass->propose_allocation = &propose_allocation_vfunc_callback;
  klass->decide_allocation = &decide_allocation_vfunc_callback;
  
}

GstCaps* BaseTransform_Class::transform_caps_vfunc_callback(GstBaseTransform* self, GstPadDirection direction, GstCaps* caps, GstCaps* filter)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return Glib::unwrap_copy(obj->transform_caps_vfunc(((PadDirection)(direction))
, Glib::wrap(caps, true)
, Glib::wrap(filter, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->transform_caps)
    return (*base->transform_caps)(self, direction, caps, filter);

  using RType = GstCaps*;
  return RType();
}
GstCaps* BaseTransform_Class::fixate_caps_vfunc_callback(GstBaseTransform* self, GstPadDirection direction, GstCaps* caps, GstCaps* othercaps)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return Glib::unwrap_copy(obj->fixate_caps_vfunc(((PadDirection)(direction))
, Glib::wrap(caps, true)
, Glib::wrap(othercaps, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->fixate_caps)
    return (*base->fixate_caps)(self, direction, caps, othercaps);

  using RType = GstCaps*;
  return RType();
}
gboolean BaseTransform_Class::get_unit_size_vfunc_callback(GstBaseTransform* self, GstCaps* caps, gsize* size)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->get_unit_size_vfunc(Glib::wrap(caps, true)
, *size
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->get_unit_size)
    return (*base->get_unit_size)(self, caps, size);

  using RType = gboolean;
  return RType();
}
gboolean BaseTransform_Class::set_caps_vfunc_callback(GstBaseTransform* self, GstCaps* incaps, GstCaps* outcaps)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->set_caps_vfunc(Glib::wrap(incaps, true)
, Glib::wrap(outcaps, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->set_caps)
    return (*base->set_caps)(self, incaps, outcaps);

  return static_cast<int>(true);
}
GstFlowReturn BaseTransform_Class::transform_ip_vfunc_callback(GstBaseTransform* self, GstBuffer* buf)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstFlowReturn)(obj->transform_ip_vfunc(Glib::wrap(buf, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->transform_ip)
    return (*base->transform_ip)(self, buf);

  using RType = GstFlowReturn;
  return RType();
}
gboolean BaseTransform_Class::src_event_vfunc_callback(GstBaseTransform* self, GstEvent* event)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->src_event_vfunc(Glib::wrap(event, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->src_event)
    return (*base->src_event)(self, event);

  using RType = gboolean;
  return RType();
}
gboolean BaseTransform_Class::sink_event_vfunc_callback(GstBaseTransform* self, GstEvent* event)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->sink_event_vfunc(Glib::wrap(event, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->sink_event)
    return (*base->sink_event)(self, event);

  using RType = gboolean;
  return RType();
}
void BaseTransform_Class::before_transform_vfunc_callback(GstBaseTransform* self, GstBuffer* buffer)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        obj->before_transform_vfunc(Glib::wrap(buffer, true)
);
        return;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->before_transform)
    (*base->before_transform)(self, buffer);
}
gboolean BaseTransform_Class::accept_caps_vfunc_callback(GstBaseTransform* self, GstPadDirection direction, GstCaps* caps)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->accept_caps_vfunc(((PadDirection)(direction))
, Glib::wrap(caps, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->accept_caps)
    return (*base->accept_caps)(self, direction, caps);

  using RType = gboolean;
  return RType();
}
gboolean BaseTransform_Class::start_vfunc_callback(GstBaseTransform* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->start_vfunc());
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->start)
    return (*base->start)(self);

  return static_cast<int>(true);
}
gboolean BaseTransform_Class::stop_vfunc_callback(GstBaseTransform* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->stop_vfunc());
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->stop)
    return (*base->stop)(self);

  return static_cast<int>(true);
}
gboolean BaseTransform_Class::filter_meta_vfunc_callback(GstBaseTransform* self, GstQuery* query, GType api, const GstStructure* params)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->filter_meta_vfunc(Glib::wrap(query, true)
, api, Glib::wrap(const_cast<GstStructure*>(params), false)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->filter_meta)
    return (*base->filter_meta)(self, query, api, params);

  return static_cast<int>(true);
}
GstFlowReturn BaseTransform_Class::submit_input_buffer_vfunc_callback(GstBaseTransform* self, gboolean is_discont, GstBuffer* input)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return ((GstFlowReturn)(obj->submit_input_buffer_vfunc(is_discont
, Glib::wrap(input, true)
)));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->submit_input_buffer)
    return (*base->submit_input_buffer)(self, is_discont, input);

  using RType = GstFlowReturn;
  return RType();
}
gboolean BaseTransform_Class::copy_metadata_vfunc_callback(GstBaseTransform* self, GstBuffer* input, GstBuffer* outbuf)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->copy_metadata_vfunc(Glib::wrap(input, true)
, Glib::wrap(outbuf, true)
));
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->copy_metadata)
    return (*base->copy_metadata)(self, input, outbuf);

  using RType = gboolean;
  return RType();
}


Glib::ObjectBase* BaseTransform_Class::wrap_new(GObject* object)
{
  return new BaseTransform((GstBaseTransform*)object);
}


/* The implementation: */

GstBaseTransform* BaseTransform::gobj_copy()
{
  reference();
  return gobj();
}

BaseTransform::BaseTransform(const Glib::ConstructParams& construct_params)
:
  Element(construct_params)
{

}

BaseTransform::BaseTransform(GstBaseTransform* castitem)
:
  Element((GstElement*)(castitem))
{}


BaseTransform::BaseTransform(BaseTransform&& src) noexcept
: Element(std::move(src))
{}

BaseTransform& BaseTransform::operator=(BaseTransform&& src) noexcept
{
  Element::operator=(std::move(src));
  return *this;
}


BaseTransform::~BaseTransform() noexcept
{}


BaseTransform::CppClassType BaseTransform::basetransform_class_; // initialize static member

GType BaseTransform::get_type()
{
  return basetransform_class_.init().get_type();
}


GType BaseTransform::get_base_type()
{
  return gst_base_transform_get_type();
}


bool BaseTransform::is_passthrough() const
{
  return gst_base_transform_is_passthrough(const_cast<GstBaseTransform*>(gobj()));
}

void BaseTransform::set_passthrough(bool passthrough)
{
  gst_base_transform_set_passthrough(gobj(), static_cast<int>(passthrough));
}

bool BaseTransform::is_in_place() const
{
  return gst_base_transform_is_in_place(const_cast<GstBaseTransform*>(gobj()));
}

void BaseTransform::set_in_place(bool in_place)
{
  gst_base_transform_set_in_place(gobj(), static_cast<int>(in_place));
}

bool BaseTransform::is_qos_enabled() const
{
  return gst_base_transform_is_qos_enabled(const_cast<GstBaseTransform*>(gobj()));
}

void BaseTransform::set_qos_enabled(bool enabled)
{
  gst_base_transform_set_qos_enabled(gobj(), static_cast<int>(enabled));
}

void BaseTransform::update_qos(double proportion, Gst::ClockTimeDiff diff, Gst::ClockTime timestamp)
{
  gst_base_transform_update_qos(gobj(), proportion, GstClockTimeDiff(diff), ((GstClockTime)(timestamp)));
}

void BaseTransform::set_gap_aware(bool gap_aware)
{
  gst_base_transform_set_gap_aware(gobj(), static_cast<int>(gap_aware));
}

void BaseTransform::reconfigure_sink()
{
  gst_base_transform_reconfigure_sink(gobj());
}

void BaseTransform::reconfigure_src()
{
  gst_base_transform_reconfigure_src(gobj());
}

void BaseTransform::set_prefer_passthrough(bool prefer_passthrough)
{
  gst_base_transform_set_prefer_passthrough(gobj(), static_cast<int>(prefer_passthrough));
}

bool BaseTransform::update_src_caps(const Glib::RefPtr<Gst::Caps>& updated_caps)
{
  return gst_base_transform_update_src_caps(gobj(), Glib::unwrap(updated_caps));
}

Glib::RefPtr<Gst::Pad> BaseTransform::get_sink_pad()
{
  Glib::RefPtr<Gst::Pad> ref_ptr(Glib::wrap(gobj()->sinkpad));

  if(ref_ptr)
    ref_ptr->reference();

  return ref_ptr;
}

Glib::RefPtr<const Gst::Pad> BaseTransform::get_sink_pad() const
{
  Glib::RefPtr<const Gst::Pad> ref_ptr(Glib::wrap(gobj()->sinkpad));

  if(ref_ptr)
    ref_ptr->reference();

  return ref_ptr;
}

Glib::RefPtr<Gst::Pad> BaseTransform::get_src_pad()
{
  Glib::RefPtr<Gst::Pad> ref_ptr(Glib::wrap(gobj()->srcpad));

  if(ref_ptr)
    ref_ptr->reference();

  return ref_ptr;
}

Glib::RefPtr<const Gst::Pad> BaseTransform::get_src_pad() const
{
  Glib::RefPtr<const Gst::Pad> ref_ptr(Glib::wrap(gobj()->srcpad));

  if(ref_ptr)
    ref_ptr->reference();

  return ref_ptr;
}


Glib::PropertyProxy< bool > BaseTransform::property_qos() 
{
  return Glib::PropertyProxy< bool >(this, "qos");
}

Glib::PropertyProxy_ReadOnly< bool > BaseTransform::property_qos() const
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "qos");
}


Glib::RefPtr<Gst::Caps> Gst::BaseTransform::transform_caps_vfunc(PadDirection direction, const Glib::RefPtr<Gst::Caps>& caps, const Glib::RefPtr<Gst::Caps>& filter) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->transform_caps)
  {
    Glib::RefPtr<Gst::Caps> retval(Glib::wrap((*base->transform_caps)(gobj(),((GstPadDirection)(direction)),Glib::unwrap(caps),Glib::unwrap(filter))));
    return retval;
  }

  using RType = Glib::RefPtr<Gst::Caps>;
  return RType();
}
Glib::RefPtr<Gst::Caps> Gst::BaseTransform::fixate_caps_vfunc(PadDirection direction, const Glib::RefPtr<Gst::Caps>& caps, const Glib::RefPtr<Gst::Caps>& othercaps) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->fixate_caps)
  {
    Glib::RefPtr<Gst::Caps> retval(Glib::wrap((*base->fixate_caps)(gobj(),((GstPadDirection)(direction)),Glib::unwrap(caps),Glib::unwrap(othercaps))));
    return retval;
  }

  using RType = Glib::RefPtr<Gst::Caps>;
  return RType();
}
bool Gst::BaseTransform::get_unit_size_vfunc(const Glib::RefPtr<Gst::Caps>& caps, gsize& size) const
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->get_unit_size)
  {
    bool retval((*base->get_unit_size)(const_cast<GstBaseTransform*>(gobj()),Glib::unwrap(caps),&(size)));
    return retval;
  }

  using RType = bool;
  return RType();
}
bool Gst::BaseTransform::set_caps_vfunc(const Glib::RefPtr<Gst::Caps>& incaps, const Glib::RefPtr<Gst::Caps>& outcaps) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->set_caps)
  {
    bool retval((*base->set_caps)(gobj(),Glib::unwrap(incaps),Glib::unwrap(outcaps)));
    return retval;
  }

  return true;
}
FlowReturn Gst::BaseTransform::transform_ip_vfunc(const Glib::RefPtr<Gst::Buffer>& buf) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->transform_ip)
  {
    FlowReturn retval(((FlowReturn)((*base->transform_ip)(gobj(),Glib::unwrap(buf)))));
    return retval;
  }

  using RType = FlowReturn;
  return RType();
}
bool Gst::BaseTransform::src_event_vfunc(const Glib::RefPtr<Gst::Event>& event) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->src_event)
  {
    bool retval((*base->src_event)(gobj(),Glib::unwrap(event)));
    return retval;
  }

  using RType = bool;
  return RType();
}
bool Gst::BaseTransform::sink_event_vfunc(const Glib::RefPtr<Gst::Event>& event) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->sink_event)
  {
    bool retval((*base->sink_event)(gobj(),Glib::unwrap(event)));
    return retval;
  }

  using RType = bool;
  return RType();
}
void Gst::BaseTransform::before_transform_vfunc(const Glib::RefPtr<Gst::Buffer>& buffer) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->before_transform)
  {
    (*base->before_transform)(gobj(),Glib::unwrap(buffer));
  }
}
bool Gst::BaseTransform::accept_caps_vfunc(PadDirection direction, const Glib::RefPtr<const Gst::Caps>& caps) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->accept_caps)
  {
    bool retval((*base->accept_caps)(gobj(),((GstPadDirection)(direction)),const_cast<GstCaps*>(Glib::unwrap(caps))));
    return retval;
  }

  using RType = bool;
  return RType();
}
bool Gst::BaseTransform::start_vfunc() 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->start)
  {
    bool retval((*base->start)(gobj()));
    return retval;
  }

  return true;
}
bool Gst::BaseTransform::stop_vfunc() 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->stop)
  {
    bool retval((*base->stop)(gobj()));
    return retval;
  }

  return true;
}
bool Gst::BaseTransform::filter_meta_vfunc(const Glib::RefPtr<Gst::Query>& query, GType api, const Gst::Structure& params) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->filter_meta)
  {
    bool retval((*base->filter_meta)(gobj(),Glib::unwrap(query),api,params.gobj()));
    return retval;
  }

  return true;
}
Gst::FlowReturn Gst::BaseTransform::submit_input_buffer_vfunc(bool is_discont, const Glib::RefPtr<Gst::Buffer>& input) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->submit_input_buffer)
  {
    Gst::FlowReturn retval(((Gst::FlowReturn)((*base->submit_input_buffer)(gobj(),static_cast<int>(is_discont),Glib::unwrap(input)))));
    return retval;
  }

  using RType = Gst::FlowReturn;
  return RType();
}
bool Gst::BaseTransform::copy_metadata_vfunc(const Glib::RefPtr<Gst::Buffer>& input, const Glib::RefPtr<Gst::Buffer>& outbuf) 
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->copy_metadata)
  {
    bool retval((*base->copy_metadata)(gobj(),Glib::unwrap(input),Glib::unwrap(outbuf)));
    return retval;
  }

  using RType = bool;
  return RType();
}


} // namespace Gst


